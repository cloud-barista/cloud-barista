// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cbmcks/cbmcks.proto

package cbmcks

import (
	context "context"
	fmt "fmt"
	_ "github.com/cloud-barista/cb-mcks/src/grpc-api/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Empty 메시지 정의
type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{0}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

// MessageResponse 응답 메시지 정의
type MessageResponse struct {
	Message              string   `protobuf:"bytes,1,opt,name=message,proto3" json:"message" yaml:"message"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageResponse) Reset()         { *m = MessageResponse{} }
func (m *MessageResponse) String() string { return proto.CompactTextString(m) }
func (*MessageResponse) ProtoMessage()    {}
func (*MessageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{1}
}
func (m *MessageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageResponse.Merge(m, src)
}
func (m *MessageResponse) XXX_Size() int {
	return m.Size()
}
func (m *MessageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MessageResponse proto.InternalMessageInfo

func (m *MessageResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// StatusResponse 응답 메시지 정의
type StatusResponse struct {
	Kind                 string   `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind" yaml:"kind"`
	Code                 int32    `protobuf:"varint,2,opt,name=code,proto3" json:"code" yaml:"code"`
	Message              string   `protobuf:"bytes,3,opt,name=message,proto3" json:"message" yaml:"message"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StatusResponse) Reset()         { *m = StatusResponse{} }
func (m *StatusResponse) String() string { return proto.CompactTextString(m) }
func (*StatusResponse) ProtoMessage()    {}
func (*StatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{2}
}
func (m *StatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusResponse.Merge(m, src)
}
func (m *StatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *StatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StatusResponse proto.InternalMessageInfo

func (m *StatusResponse) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *StatusResponse) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *StatusResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type ClusterInfoResponse struct {
	Item                 *ClusterInfo `protobuf:"bytes,1,opt,name=item,proto3" json:"item" yaml:"item"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ClusterInfoResponse) Reset()         { *m = ClusterInfoResponse{} }
func (m *ClusterInfoResponse) String() string { return proto.CompactTextString(m) }
func (*ClusterInfoResponse) ProtoMessage()    {}
func (*ClusterInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{3}
}
func (m *ClusterInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterInfoResponse.Merge(m, src)
}
func (m *ClusterInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *ClusterInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterInfoResponse proto.InternalMessageInfo

func (m *ClusterInfoResponse) GetItem() *ClusterInfo {
	if m != nil {
		return m.Item
	}
	return nil
}

type ListClusterInfoResponse struct {
	Kind                 string         `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind" yaml:"kind"`
	Items                []*ClusterInfo `protobuf:"bytes,2,rep,name=items,proto3" json:"items" yaml:"items"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ListClusterInfoResponse) Reset()         { *m = ListClusterInfoResponse{} }
func (m *ListClusterInfoResponse) String() string { return proto.CompactTextString(m) }
func (*ListClusterInfoResponse) ProtoMessage()    {}
func (*ListClusterInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{4}
}
func (m *ListClusterInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListClusterInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListClusterInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListClusterInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListClusterInfoResponse.Merge(m, src)
}
func (m *ListClusterInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListClusterInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListClusterInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListClusterInfoResponse proto.InternalMessageInfo

func (m *ListClusterInfoResponse) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *ListClusterInfoResponse) GetItems() []*ClusterInfo {
	if m != nil {
		return m.Items
	}
	return nil
}

type ClusterInfo struct {
	Name                 string             `protobuf:"bytes,1,opt,name=name,proto3" json:"name" yaml:"name"`
	Kind                 string             `protobuf:"bytes,2,opt,name=kind,proto3" json:"kind" yaml:"kind"`
	Status               *ClusterStatusInfo `protobuf:"bytes,3,opt,name=status,proto3" json:"status" yaml:"status"`
	Mcis                 string             `protobuf:"bytes,4,opt,name=mcis,proto3" json:"mcis" yaml:"mcis"`
	Namespace            string             `protobuf:"bytes,5,opt,name=namespace,proto3" json:"namespace" yaml:"namespace"`
	K8SVersion           string             `protobuf:"bytes,6,opt,name=k8s_version,json=k8sVersion,proto3" json:"k8sVersion" yaml:"k8sVersion"`
	ClusterConfig        string             `protobuf:"bytes,7,opt,name=cluster_config,json=clusterConfig,proto3" json:"clusterConfig" yaml:"clusterConfig"`
	CpLeader             string             `protobuf:"bytes,8,opt,name=cp_leader,json=cpLeader,proto3" json:"cpLeader" yaml:"cpLeader"`
	NetworkCni           string             `protobuf:"bytes,9,opt,name=network_cni,json=networkCni,proto3" json:"networkCni" yaml:"networkCni"`
	Label                string             `protobuf:"bytes,10,opt,name=label,proto3" json:"label" yaml:"label"`
	InstallMonAgent      string             `protobuf:"bytes,11,opt,name=install_mon_agent,json=installMonAgent,proto3" json:"installMonAgent" yaml:"installMonAgent"`
	Description          string             `protobuf:"bytes,12,opt,name=description,proto3" json:"description" yaml:"description"`
	CreatedTime          string             `protobuf:"bytes,13,opt,name=created_time,json=createdTime,proto3" json:"createdTime" yaml:"createdTime"`
	Nodes                []*NodeInfo        `protobuf:"bytes,14,rep,name=nodes,proto3" json:"nodes" yaml:"nodes"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ClusterInfo) Reset()         { *m = ClusterInfo{} }
func (m *ClusterInfo) String() string { return proto.CompactTextString(m) }
func (*ClusterInfo) ProtoMessage()    {}
func (*ClusterInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{5}
}
func (m *ClusterInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterInfo.Merge(m, src)
}
func (m *ClusterInfo) XXX_Size() int {
	return m.Size()
}
func (m *ClusterInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterInfo proto.InternalMessageInfo

func (m *ClusterInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ClusterInfo) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *ClusterInfo) GetStatus() *ClusterStatusInfo {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *ClusterInfo) GetMcis() string {
	if m != nil {
		return m.Mcis
	}
	return ""
}

func (m *ClusterInfo) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ClusterInfo) GetK8SVersion() string {
	if m != nil {
		return m.K8SVersion
	}
	return ""
}

func (m *ClusterInfo) GetClusterConfig() string {
	if m != nil {
		return m.ClusterConfig
	}
	return ""
}

func (m *ClusterInfo) GetCpLeader() string {
	if m != nil {
		return m.CpLeader
	}
	return ""
}

func (m *ClusterInfo) GetNetworkCni() string {
	if m != nil {
		return m.NetworkCni
	}
	return ""
}

func (m *ClusterInfo) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *ClusterInfo) GetInstallMonAgent() string {
	if m != nil {
		return m.InstallMonAgent
	}
	return ""
}

func (m *ClusterInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ClusterInfo) GetCreatedTime() string {
	if m != nil {
		return m.CreatedTime
	}
	return ""
}

func (m *ClusterInfo) GetNodes() []*NodeInfo {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type ClusterCreateRequest struct {
	Namespace            string             `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace" yaml:"namespace"`
	Minorversion         string             `protobuf:"bytes,2,opt,name=minorversion,proto3" json:"minorversion" yaml:"minorversion"`
	Patchversion         string             `protobuf:"bytes,3,opt,name=patchversion,proto3" json:"patchversion" yaml:"patchversion"`
	Item                 *ClusterCreateInfo `protobuf:"bytes,4,opt,name=item,json=ReqInfo,proto3" json:"ReqInfo" yaml:"ReqInfo"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ClusterCreateRequest) Reset()         { *m = ClusterCreateRequest{} }
func (m *ClusterCreateRequest) String() string { return proto.CompactTextString(m) }
func (*ClusterCreateRequest) ProtoMessage()    {}
func (*ClusterCreateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{6}
}
func (m *ClusterCreateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterCreateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterCreateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterCreateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterCreateRequest.Merge(m, src)
}
func (m *ClusterCreateRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClusterCreateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterCreateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterCreateRequest proto.InternalMessageInfo

func (m *ClusterCreateRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ClusterCreateRequest) GetMinorversion() string {
	if m != nil {
		return m.Minorversion
	}
	return ""
}

func (m *ClusterCreateRequest) GetPatchversion() string {
	if m != nil {
		return m.Patchversion
	}
	return ""
}

func (m *ClusterCreateRequest) GetItem() *ClusterCreateInfo {
	if m != nil {
		return m.Item
	}
	return nil
}

type ClusterCreateInfo struct {
	Name                 string        `protobuf:"bytes,1,opt,name=name,proto3" json:"name" yaml:"name"`
	ControlPlane         []*NodeConfig `protobuf:"bytes,2,rep,name=control_plane,json=controlPlane,proto3" json:"controlPlane" yaml:"controlPlane"`
	Worker               []*NodeConfig `protobuf:"bytes,3,rep,name=worker,proto3" json:"worker" yaml:"worker"`
	Config               *Config       `protobuf:"bytes,4,opt,name=config,proto3" json:"config" yaml:"config"`
	Label                string        `protobuf:"bytes,5,opt,name=label,proto3" json:"label" yaml:"label"`
	InstallMonAgent      string        `protobuf:"bytes,6,opt,name=install_mon_agent,json=installMonAgent,proto3" json:"installMonAgent" yaml:"installMonAgent"`
	Description          string        `protobuf:"bytes,7,opt,name=description,proto3" json:"description" yaml:"description"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ClusterCreateInfo) Reset()         { *m = ClusterCreateInfo{} }
func (m *ClusterCreateInfo) String() string { return proto.CompactTextString(m) }
func (*ClusterCreateInfo) ProtoMessage()    {}
func (*ClusterCreateInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{7}
}
func (m *ClusterCreateInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterCreateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterCreateInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterCreateInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterCreateInfo.Merge(m, src)
}
func (m *ClusterCreateInfo) XXX_Size() int {
	return m.Size()
}
func (m *ClusterCreateInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterCreateInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterCreateInfo proto.InternalMessageInfo

func (m *ClusterCreateInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ClusterCreateInfo) GetControlPlane() []*NodeConfig {
	if m != nil {
		return m.ControlPlane
	}
	return nil
}

func (m *ClusterCreateInfo) GetWorker() []*NodeConfig {
	if m != nil {
		return m.Worker
	}
	return nil
}

func (m *ClusterCreateInfo) GetConfig() *Config {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *ClusterCreateInfo) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *ClusterCreateInfo) GetInstallMonAgent() string {
	if m != nil {
		return m.InstallMonAgent
	}
	return ""
}

func (m *ClusterCreateInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type NodeConfig struct {
	Connection           string   `protobuf:"bytes,1,opt,name=connection,proto3" json:"connection" yaml:"connection"`
	Count                int32    `protobuf:"varint,2,opt,name=count,proto3" json:"count" yaml:"count"`
	Spec                 string   `protobuf:"bytes,3,opt,name=spec,proto3" json:"spec" yaml:"spec"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeConfig) Reset()         { *m = NodeConfig{} }
func (m *NodeConfig) String() string { return proto.CompactTextString(m) }
func (*NodeConfig) ProtoMessage()    {}
func (*NodeConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{8}
}
func (m *NodeConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeConfig.Merge(m, src)
}
func (m *NodeConfig) XXX_Size() int {
	return m.Size()
}
func (m *NodeConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeConfig.DiscardUnknown(m)
}

var xxx_messageInfo_NodeConfig proto.InternalMessageInfo

func (m *NodeConfig) GetConnection() string {
	if m != nil {
		return m.Connection
	}
	return ""
}

func (m *NodeConfig) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *NodeConfig) GetSpec() string {
	if m != nil {
		return m.Spec
	}
	return ""
}

type Config struct {
	Kubernetes           *Kubernetes `protobuf:"bytes,1,opt,name=kubernetes,proto3" json:"kubernetes" yaml:"kubernetes"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Config) Reset()         { *m = Config{} }
func (m *Config) String() string { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()    {}
func (*Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{9}
}
func (m *Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Config.Merge(m, src)
}
func (m *Config) XXX_Size() int {
	return m.Size()
}
func (m *Config) XXX_DiscardUnknown() {
	xxx_messageInfo_Config.DiscardUnknown(m)
}

var xxx_messageInfo_Config proto.InternalMessageInfo

func (m *Config) GetKubernetes() *Kubernetes {
	if m != nil {
		return m.Kubernetes
	}
	return nil
}

type Kubernetes struct {
	NetworkCni           string   `protobuf:"bytes,1,opt,name=network_cni,json=networkCni,proto3" json:"networkCni" yaml:"networkCni"`
	PodCidr              string   `protobuf:"bytes,2,opt,name=pod_cidr,json=podCidr,proto3" json:"podCidr" yaml:"podCidr"`
	ServiceCidr          string   `protobuf:"bytes,3,opt,name=service_cidr,json=serviceCidr,proto3" json:"serviceCidr" yaml:"serviceCidr"`
	ServicDnsDomain      string   `protobuf:"bytes,4,opt,name=servic_dns_domain,json=serviceDnsDomain,proto3" json:"serviceDnsDomain" yaml:"serviceDnsDomain"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Kubernetes) Reset()         { *m = Kubernetes{} }
func (m *Kubernetes) String() string { return proto.CompactTextString(m) }
func (*Kubernetes) ProtoMessage()    {}
func (*Kubernetes) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{10}
}
func (m *Kubernetes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Kubernetes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Kubernetes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Kubernetes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Kubernetes.Merge(m, src)
}
func (m *Kubernetes) XXX_Size() int {
	return m.Size()
}
func (m *Kubernetes) XXX_DiscardUnknown() {
	xxx_messageInfo_Kubernetes.DiscardUnknown(m)
}

var xxx_messageInfo_Kubernetes proto.InternalMessageInfo

func (m *Kubernetes) GetNetworkCni() string {
	if m != nil {
		return m.NetworkCni
	}
	return ""
}

func (m *Kubernetes) GetPodCidr() string {
	if m != nil {
		return m.PodCidr
	}
	return ""
}

func (m *Kubernetes) GetServiceCidr() string {
	if m != nil {
		return m.ServiceCidr
	}
	return ""
}

func (m *Kubernetes) GetServicDnsDomain() string {
	if m != nil {
		return m.ServicDnsDomain
	}
	return ""
}

type ClusterAllQryRequest struct {
	Namespace            string   `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace" yaml:"namespace"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterAllQryRequest) Reset()         { *m = ClusterAllQryRequest{} }
func (m *ClusterAllQryRequest) String() string { return proto.CompactTextString(m) }
func (*ClusterAllQryRequest) ProtoMessage()    {}
func (*ClusterAllQryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{11}
}
func (m *ClusterAllQryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterAllQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterAllQryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterAllQryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterAllQryRequest.Merge(m, src)
}
func (m *ClusterAllQryRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClusterAllQryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterAllQryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterAllQryRequest proto.InternalMessageInfo

func (m *ClusterAllQryRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

type ClusterQryRequest struct {
	Namespace            string   `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace" yaml:"namespace"`
	Cluster              string   `protobuf:"bytes,2,opt,name=cluster,proto3" json:"cluster" yaml:"cluster"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterQryRequest) Reset()         { *m = ClusterQryRequest{} }
func (m *ClusterQryRequest) String() string { return proto.CompactTextString(m) }
func (*ClusterQryRequest) ProtoMessage()    {}
func (*ClusterQryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{12}
}
func (m *ClusterQryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterQryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterQryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterQryRequest.Merge(m, src)
}
func (m *ClusterQryRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClusterQryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterQryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterQryRequest proto.InternalMessageInfo

func (m *ClusterQryRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ClusterQryRequest) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

type ClusterStatusInfo struct {
	Phase                string   `protobuf:"bytes,1,opt,name=phase,proto3" json:"phase" yaml:"phase"`
	Reason               string   `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason" yaml:"reason"`
	Message              string   `protobuf:"bytes,3,opt,name=message,proto3" json:"message" yaml:"message"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterStatusInfo) Reset()         { *m = ClusterStatusInfo{} }
func (m *ClusterStatusInfo) String() string { return proto.CompactTextString(m) }
func (*ClusterStatusInfo) ProtoMessage()    {}
func (*ClusterStatusInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{13}
}
func (m *ClusterStatusInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterStatusInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterStatusInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterStatusInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterStatusInfo.Merge(m, src)
}
func (m *ClusterStatusInfo) XXX_Size() int {
	return m.Size()
}
func (m *ClusterStatusInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterStatusInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterStatusInfo proto.InternalMessageInfo

func (m *ClusterStatusInfo) GetPhase() string {
	if m != nil {
		return m.Phase
	}
	return ""
}

func (m *ClusterStatusInfo) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *ClusterStatusInfo) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type NodeInfoResponse struct {
	Item                 *NodeInfo `protobuf:"bytes,1,opt,name=item,proto3" json:"item" yaml:"item"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *NodeInfoResponse) Reset()         { *m = NodeInfoResponse{} }
func (m *NodeInfoResponse) String() string { return proto.CompactTextString(m) }
func (*NodeInfoResponse) ProtoMessage()    {}
func (*NodeInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{14}
}
func (m *NodeInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInfoResponse.Merge(m, src)
}
func (m *NodeInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *NodeInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInfoResponse proto.InternalMessageInfo

func (m *NodeInfoResponse) GetItem() *NodeInfo {
	if m != nil {
		return m.Item
	}
	return nil
}

type ListNodeInfoResponse struct {
	Kind                 string      `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind" yaml:"kind"`
	Items                []*NodeInfo `protobuf:"bytes,2,rep,name=items,proto3" json:"items" yaml:"items"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ListNodeInfoResponse) Reset()         { *m = ListNodeInfoResponse{} }
func (m *ListNodeInfoResponse) String() string { return proto.CompactTextString(m) }
func (*ListNodeInfoResponse) ProtoMessage()    {}
func (*ListNodeInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{15}
}
func (m *ListNodeInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListNodeInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListNodeInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListNodeInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListNodeInfoResponse.Merge(m, src)
}
func (m *ListNodeInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListNodeInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListNodeInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListNodeInfoResponse proto.InternalMessageInfo

func (m *ListNodeInfoResponse) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *ListNodeInfoResponse) GetItems() []*NodeInfo {
	if m != nil {
		return m.Items
	}
	return nil
}

type NodeInfo struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name" yaml:"name"`
	Kind                 string   `protobuf:"bytes,2,opt,name=kind,proto3" json:"kind" yaml:"kind"`
	Credential           string   `protobuf:"bytes,3,opt,name=credential,proto3" json:"credential" yaml:"credential"`
	PublicIp             string   `protobuf:"bytes,4,opt,name=public_ip,json=publicIp,proto3" json:"publicIp" yaml:"publicIp"`
	Role                 string   `protobuf:"bytes,5,opt,name=role,proto3" json:"role" yaml:"role"`
	Spec                 string   `protobuf:"bytes,6,opt,name=spec,proto3" json:"spec" yaml:"spec"`
	Csp                  string   `protobuf:"bytes,7,opt,name=csp,proto3" json:"csp" yaml:"csp"`
	CreatedTime          string   `protobuf:"bytes,8,opt,name=created_time,json=createdTime,proto3" json:"createdTime" yaml:"createdTime"`
	CspLabel             string   `protobuf:"bytes,9,opt,name=csp_label,json=cspLabel,proto3" json:"cspLabel" yaml:"cspLabel"`
	RegionLabel          string   `protobuf:"bytes,10,opt,name=region_label,json=regionLabel,proto3" json:"regionLabel" yaml:"regionLabel"`
	ZoneLabel            string   `protobuf:"bytes,11,opt,name=zone_label,json=zoneLabel,proto3" json:"zoneLabel" yaml:"zoneLabel"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeInfo) Reset()         { *m = NodeInfo{} }
func (m *NodeInfo) String() string { return proto.CompactTextString(m) }
func (*NodeInfo) ProtoMessage()    {}
func (*NodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{16}
}
func (m *NodeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInfo.Merge(m, src)
}
func (m *NodeInfo) XXX_Size() int {
	return m.Size()
}
func (m *NodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInfo proto.InternalMessageInfo

func (m *NodeInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NodeInfo) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *NodeInfo) GetCredential() string {
	if m != nil {
		return m.Credential
	}
	return ""
}

func (m *NodeInfo) GetPublicIp() string {
	if m != nil {
		return m.PublicIp
	}
	return ""
}

func (m *NodeInfo) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *NodeInfo) GetSpec() string {
	if m != nil {
		return m.Spec
	}
	return ""
}

func (m *NodeInfo) GetCsp() string {
	if m != nil {
		return m.Csp
	}
	return ""
}

func (m *NodeInfo) GetCreatedTime() string {
	if m != nil {
		return m.CreatedTime
	}
	return ""
}

func (m *NodeInfo) GetCspLabel() string {
	if m != nil {
		return m.CspLabel
	}
	return ""
}

func (m *NodeInfo) GetRegionLabel() string {
	if m != nil {
		return m.RegionLabel
	}
	return ""
}

func (m *NodeInfo) GetZoneLabel() string {
	if m != nil {
		return m.ZoneLabel
	}
	return ""
}

type NodeCreateRequest struct {
	Namespace            string          `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace" yaml:"namespace"`
	Cluster              string          `protobuf:"bytes,2,opt,name=cluster,proto3" json:"cluster" yaml:"cluster"`
	Item                 *NodeCreateInfo `protobuf:"bytes,3,opt,name=item,json=ReqInfo,proto3" json:"ReqInfo" yaml:"ReqInfo"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *NodeCreateRequest) Reset()         { *m = NodeCreateRequest{} }
func (m *NodeCreateRequest) String() string { return proto.CompactTextString(m) }
func (*NodeCreateRequest) ProtoMessage()    {}
func (*NodeCreateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{17}
}
func (m *NodeCreateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeCreateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeCreateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeCreateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeCreateRequest.Merge(m, src)
}
func (m *NodeCreateRequest) XXX_Size() int {
	return m.Size()
}
func (m *NodeCreateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeCreateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NodeCreateRequest proto.InternalMessageInfo

func (m *NodeCreateRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *NodeCreateRequest) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *NodeCreateRequest) GetItem() *NodeCreateInfo {
	if m != nil {
		return m.Item
	}
	return nil
}

type NodeCreateInfo struct {
	ControlPlane         []*NodeConfig `protobuf:"bytes,1,rep,name=control_plane,json=controlPlane,proto3" json:"controlPlane" yaml:"controlPlane"`
	Worker               []*NodeConfig `protobuf:"bytes,2,rep,name=worker,proto3" json:"worker" yaml:"worker"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *NodeCreateInfo) Reset()         { *m = NodeCreateInfo{} }
func (m *NodeCreateInfo) String() string { return proto.CompactTextString(m) }
func (*NodeCreateInfo) ProtoMessage()    {}
func (*NodeCreateInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{18}
}
func (m *NodeCreateInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeCreateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeCreateInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeCreateInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeCreateInfo.Merge(m, src)
}
func (m *NodeCreateInfo) XXX_Size() int {
	return m.Size()
}
func (m *NodeCreateInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeCreateInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NodeCreateInfo proto.InternalMessageInfo

func (m *NodeCreateInfo) GetControlPlane() []*NodeConfig {
	if m != nil {
		return m.ControlPlane
	}
	return nil
}

func (m *NodeCreateInfo) GetWorker() []*NodeConfig {
	if m != nil {
		return m.Worker
	}
	return nil
}

type NodeAllQryRequest struct {
	Namespace            string   `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace" yaml:"namespace"`
	Cluster              string   `protobuf:"bytes,2,opt,name=cluster,proto3" json:"cluster" yaml:"cluster"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeAllQryRequest) Reset()         { *m = NodeAllQryRequest{} }
func (m *NodeAllQryRequest) String() string { return proto.CompactTextString(m) }
func (*NodeAllQryRequest) ProtoMessage()    {}
func (*NodeAllQryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{19}
}
func (m *NodeAllQryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeAllQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeAllQryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeAllQryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeAllQryRequest.Merge(m, src)
}
func (m *NodeAllQryRequest) XXX_Size() int {
	return m.Size()
}
func (m *NodeAllQryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeAllQryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NodeAllQryRequest proto.InternalMessageInfo

func (m *NodeAllQryRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *NodeAllQryRequest) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

type NodeQryRequest struct {
	Namespace            string   `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace" yaml:"namespace"`
	Cluster              string   `protobuf:"bytes,2,opt,name=cluster,proto3" json:"cluster" yaml:"cluster"`
	Node                 string   `protobuf:"bytes,3,opt,name=node,proto3" json:"node" yaml:"node"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeQryRequest) Reset()         { *m = NodeQryRequest{} }
func (m *NodeQryRequest) String() string { return proto.CompactTextString(m) }
func (*NodeQryRequest) ProtoMessage()    {}
func (*NodeQryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{20}
}
func (m *NodeQryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeQryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeQryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeQryRequest.Merge(m, src)
}
func (m *NodeQryRequest) XXX_Size() int {
	return m.Size()
}
func (m *NodeQryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeQryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NodeQryRequest proto.InternalMessageInfo

func (m *NodeQryRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *NodeQryRequest) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *NodeQryRequest) GetNode() string {
	if m != nil {
		return m.Node
	}
	return ""
}

type SpecInfoResponse struct {
	Item                 *SpecInfo `protobuf:"bytes,1,opt,name=item,proto3" json:"item" yaml:"item"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *SpecInfoResponse) Reset()         { *m = SpecInfoResponse{} }
func (m *SpecInfoResponse) String() string { return proto.CompactTextString(m) }
func (*SpecInfoResponse) ProtoMessage()    {}
func (*SpecInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{21}
}
func (m *SpecInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpecInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpecInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpecInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpecInfoResponse.Merge(m, src)
}
func (m *SpecInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpecInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpecInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpecInfoResponse proto.InternalMessageInfo

func (m *SpecInfoResponse) GetItem() *SpecInfo {
	if m != nil {
		return m.Item
	}
	return nil
}

type ListSpecInfoResponse struct {
	Kind                 string      `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind" yaml:"kind"`
	Items                []*SpecInfo `protobuf:"bytes,2,rep,name=items,proto3" json:"items" yaml:"items"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ListSpecInfoResponse) Reset()         { *m = ListSpecInfoResponse{} }
func (m *ListSpecInfoResponse) String() string { return proto.CompactTextString(m) }
func (*ListSpecInfoResponse) ProtoMessage()    {}
func (*ListSpecInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{22}
}
func (m *ListSpecInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListSpecInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListSpecInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListSpecInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListSpecInfoResponse.Merge(m, src)
}
func (m *ListSpecInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListSpecInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListSpecInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListSpecInfoResponse proto.InternalMessageInfo

func (m *ListSpecInfoResponse) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *ListSpecInfoResponse) GetItems() []*SpecInfo {
	if m != nil {
		return m.Items
	}
	return nil
}

type SpecInfo struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name" yaml:"name"`
	Memory               string   `protobuf:"bytes,2,opt,name=memory,proto3" json:"memory" yaml:"memory"`
	Cpu                  *CpuInfo `protobuf:"bytes,3,opt,name=cpu,proto3" json:"cpu" yaml:"cpu"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SpecInfo) Reset()         { *m = SpecInfo{} }
func (m *SpecInfo) String() string { return proto.CompactTextString(m) }
func (*SpecInfo) ProtoMessage()    {}
func (*SpecInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{23}
}
func (m *SpecInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpecInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpecInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpecInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpecInfo.Merge(m, src)
}
func (m *SpecInfo) XXX_Size() int {
	return m.Size()
}
func (m *SpecInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SpecInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SpecInfo proto.InternalMessageInfo

func (m *SpecInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SpecInfo) GetMemory() string {
	if m != nil {
		return m.Memory
	}
	return ""
}

func (m *SpecInfo) GetCpu() *CpuInfo {
	if m != nil {
		return m.Cpu
	}
	return nil
}

type CpuInfo struct {
	Clock                string   `protobuf:"bytes,1,opt,name=clock,proto3" json:"clock" yaml:"clock"`
	Count                string   `protobuf:"bytes,2,opt,name=count,proto3" json:"count" yaml:"count"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CpuInfo) Reset()         { *m = CpuInfo{} }
func (m *CpuInfo) String() string { return proto.CompactTextString(m) }
func (*CpuInfo) ProtoMessage()    {}
func (*CpuInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{24}
}
func (m *CpuInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CpuInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CpuInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CpuInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CpuInfo.Merge(m, src)
}
func (m *CpuInfo) XXX_Size() int {
	return m.Size()
}
func (m *CpuInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CpuInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CpuInfo proto.InternalMessageInfo

func (m *CpuInfo) GetClock() string {
	if m != nil {
		return m.Clock
	}
	return ""
}

func (m *CpuInfo) GetCount() string {
	if m != nil {
		return m.Count
	}
	return ""
}

type SpecQryRequest struct {
	Connectionname       string   `protobuf:"bytes,1,opt,name=connectionname,json=connectionName,proto3" json:"connectionName" yaml:"connectionName"`
	ControlPlane         string   `protobuf:"bytes,2,opt,name=control_plane,json=cluster,proto3" json:"cluster" yaml:"cluster"`
	CpuMin               string   `protobuf:"bytes,3,opt,name=cpu_min,json=cpuMin,proto3" json:"cpuMin" yaml:"cpuMin"`
	CpuMax               string   `protobuf:"bytes,4,opt,name=cpu_max,json=cpuMax,proto3" json:"cpuMax" yaml:"cpuMax"`
	MemoryMin            string   `protobuf:"bytes,5,opt,name=memory_min,json=memoryMin,proto3" json:"memoryMin" yaml:"memoryMin"`
	MemoryMax            string   `protobuf:"bytes,6,opt,name=memory_max,json=memoryMax,proto3" json:"memoryMax" yaml:"memoryMax"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SpecQryRequest) Reset()         { *m = SpecQryRequest{} }
func (m *SpecQryRequest) String() string { return proto.CompactTextString(m) }
func (*SpecQryRequest) ProtoMessage()    {}
func (*SpecQryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e98b9bfafe16c0f, []int{25}
}
func (m *SpecQryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpecQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpecQryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpecQryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpecQryRequest.Merge(m, src)
}
func (m *SpecQryRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpecQryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpecQryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpecQryRequest proto.InternalMessageInfo

func (m *SpecQryRequest) GetConnectionname() string {
	if m != nil {
		return m.Connectionname
	}
	return ""
}

func (m *SpecQryRequest) GetControlPlane() string {
	if m != nil {
		return m.ControlPlane
	}
	return ""
}

func (m *SpecQryRequest) GetCpuMin() string {
	if m != nil {
		return m.CpuMin
	}
	return ""
}

func (m *SpecQryRequest) GetCpuMax() string {
	if m != nil {
		return m.CpuMax
	}
	return ""
}

func (m *SpecQryRequest) GetMemoryMin() string {
	if m != nil {
		return m.MemoryMin
	}
	return ""
}

func (m *SpecQryRequest) GetMemoryMax() string {
	if m != nil {
		return m.MemoryMax
	}
	return ""
}

func init() {
	proto.RegisterType((*Empty)(nil), "cbmcks.Empty")
	proto.RegisterType((*MessageResponse)(nil), "cbmcks.MessageResponse")
	proto.RegisterType((*StatusResponse)(nil), "cbmcks.StatusResponse")
	proto.RegisterType((*ClusterInfoResponse)(nil), "cbmcks.ClusterInfoResponse")
	proto.RegisterType((*ListClusterInfoResponse)(nil), "cbmcks.ListClusterInfoResponse")
	proto.RegisterType((*ClusterInfo)(nil), "cbmcks.ClusterInfo")
	proto.RegisterType((*ClusterCreateRequest)(nil), "cbmcks.ClusterCreateRequest")
	proto.RegisterType((*ClusterCreateInfo)(nil), "cbmcks.ClusterCreateInfo")
	proto.RegisterType((*NodeConfig)(nil), "cbmcks.NodeConfig")
	proto.RegisterType((*Config)(nil), "cbmcks.Config")
	proto.RegisterType((*Kubernetes)(nil), "cbmcks.Kubernetes")
	proto.RegisterType((*ClusterAllQryRequest)(nil), "cbmcks.ClusterAllQryRequest")
	proto.RegisterType((*ClusterQryRequest)(nil), "cbmcks.ClusterQryRequest")
	proto.RegisterType((*ClusterStatusInfo)(nil), "cbmcks.ClusterStatusInfo")
	proto.RegisterType((*NodeInfoResponse)(nil), "cbmcks.NodeInfoResponse")
	proto.RegisterType((*ListNodeInfoResponse)(nil), "cbmcks.ListNodeInfoResponse")
	proto.RegisterType((*NodeInfo)(nil), "cbmcks.NodeInfo")
	proto.RegisterType((*NodeCreateRequest)(nil), "cbmcks.NodeCreateRequest")
	proto.RegisterType((*NodeCreateInfo)(nil), "cbmcks.NodeCreateInfo")
	proto.RegisterType((*NodeAllQryRequest)(nil), "cbmcks.NodeAllQryRequest")
	proto.RegisterType((*NodeQryRequest)(nil), "cbmcks.NodeQryRequest")
	proto.RegisterType((*SpecInfoResponse)(nil), "cbmcks.SpecInfoResponse")
	proto.RegisterType((*ListSpecInfoResponse)(nil), "cbmcks.ListSpecInfoResponse")
	proto.RegisterType((*SpecInfo)(nil), "cbmcks.SpecInfo")
	proto.RegisterType((*CpuInfo)(nil), "cbmcks.CpuInfo")
	proto.RegisterType((*SpecQryRequest)(nil), "cbmcks.SpecQryRequest")
}

func init() { proto.RegisterFile("cbmcks/cbmcks.proto", fileDescriptor_6e98b9bfafe16c0f) }

var fileDescriptor_6e98b9bfafe16c0f = []byte{
	// 1869 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0xcf, 0x6f, 0xdc, 0x4e,
	0x15, 0x8f, 0xb3, 0xd9, 0xdd, 0xe4, 0x6d, 0x76, 0x93, 0x38, 0xf9, 0x7e, 0xb3, 0xdf, 0x7c, 0xbf,
	0xc4, 0x65, 0x10, 0x6a, 0x51, 0x45, 0x23, 0x35, 0x48, 0x44, 0x88, 0x42, 0xd3, 0x4d, 0x49, 0x4b,
	0x93, 0xd0, 0x4e, 0x11, 0x15, 0x12, 0xd2, 0xe2, 0xd8, 0xd3, 0xd4, 0x5a, 0xaf, 0xed, 0xda, 0xde,
	0x92, 0x70, 0x87, 0x13, 0xdc, 0x38, 0x70, 0xaf, 0xc4, 0x15, 0x09, 0x21, 0xf5, 0xc0, 0x8d, 0x13,
	0x47, 0xee, 0x48, 0x16, 0x2a, 0xb7, 0x3d, 0xee, 0x1f, 0x80, 0xd0, 0xbc, 0x19, 0x7b, 0xc6, 0xbb,
	0x49, 0xf3, 0xa3, 0xa9, 0xc4, 0x69, 0xf3, 0x3e, 0xef, 0xcd, 0xc7, 0x6f, 0xc6, 0x33, 0xef, 0x7d,
	0x3c, 0x81, 0x65, 0xe7, 0xb0, 0xef, 0xf4, 0x92, 0x0d, 0xf1, 0x73, 0x27, 0x8a, 0xc3, 0x34, 0x34,
	0x6b, 0xc2, 0x5a, 0x5b, 0x39, 0x0a, 0x8f, 0x42, 0x84, 0x36, 0xf8, 0x5f, 0xc2, 0x4b, 0xea, 0x50,
	0x7d, 0xd8, 0x8f, 0xd2, 0x13, 0xf2, 0x63, 0x58, 0xd8, 0x67, 0x49, 0x62, 0x1f, 0x31, 0xca, 0x92,
	0x28, 0x0c, 0x12, 0x66, 0x7e, 0x17, 0xea, 0x7d, 0x01, 0xb5, 0x8d, 0x1b, 0xc6, 0xad, 0xb9, 0x07,
	0x5f, 0x1b, 0x66, 0x56, 0x0e, 0x8d, 0x32, 0xab, 0x75, 0x62, 0xf7, 0xfd, 0xef, 0x11, 0x09, 0x10,
	0x9a, 0xbb, 0xc8, 0x5b, 0x03, 0x5a, 0xcf, 0x53, 0x3b, 0x1d, 0x24, 0x05, 0xd7, 0x6d, 0x98, 0xe9,
	0x79, 0x81, 0x2b, 0x89, 0x56, 0x87, 0x99, 0x85, 0xf6, 0x28, 0xb3, 0x1a, 0x82, 0x85, 0x5b, 0x84,
	0x22, 0xc8, 0x83, 0x9d, 0xd0, 0x65, 0xed, 0xe9, 0x1b, 0xc6, 0xad, 0xaa, 0x08, 0xe6, 0xb6, 0x0a,
	0xe6, 0x16, 0xa1, 0x08, 0xea, 0x59, 0x56, 0x2e, 0x95, 0xe5, 0x0b, 0x58, 0xee, 0xf8, 0x83, 0x24,
	0x65, 0xf1, 0xe3, 0xe0, 0x65, 0x58, 0x64, 0x7a, 0x1f, 0x66, 0xbc, 0x94, 0xf5, 0x31, 0xd3, 0xc6,
	0xdd, 0xe5, 0x3b, 0x72, 0x31, 0xb5, 0x50, 0x91, 0x11, 0x0f, 0x52, 0x19, 0x71, 0x8b, 0x50, 0x04,
	0xc9, 0xef, 0x0c, 0x58, 0xdd, 0xf3, 0x92, 0xf4, 0x34, 0xf6, 0x4b, 0xad, 0xc3, 0x0e, 0x54, 0x39,
	0x61, 0xd2, 0x9e, 0xbe, 0x51, 0x39, 0x2b, 0x97, 0x2f, 0x86, 0x99, 0x25, 0xa2, 0x46, 0x99, 0x35,
	0xaf, 0x92, 0x49, 0x08, 0x15, 0x30, 0x79, 0x5b, 0x87, 0x86, 0x36, 0x82, 0xa7, 0x10, 0xd8, 0x7d,
	0xa6, 0xa7, 0xc0, 0x6d, 0x95, 0x02, 0xb7, 0x08, 0x45, 0xb0, 0xc8, 0x77, 0xfa, 0x22, 0xf9, 0x1e,
	0x40, 0x2d, 0xc1, 0xd7, 0x8e, 0x6f, 0xa2, 0x71, 0xf7, 0x8b, 0xb1, 0x84, 0xc5, 0x9e, 0xc0, 0xb4,
	0xbf, 0x1c, 0x66, 0x96, 0x0c, 0x1e, 0x65, 0x56, 0x53, 0x70, 0x09, 0x9b, 0x50, 0xe9, 0xe0, 0x0f,
	0xef, 0x3b, 0x5e, 0xd2, 0x9e, 0x51, 0x0f, 0xe7, 0xb6, 0x7a, 0x38, 0xb7, 0x08, 0x45, 0xd0, 0xfc,
	0x21, 0xcc, 0xf1, 0x8c, 0x93, 0xc8, 0x76, 0x58, 0xbb, 0x8a, 0x23, 0xbe, 0x3e, 0xcc, 0x2c, 0x05,
	0x8e, 0x32, 0x6b, 0x51, 0x4d, 0x10, 0x21, 0x42, 0x95, 0xdb, 0xdc, 0x81, 0x46, 0x6f, 0x2b, 0xe9,
	0xbe, 0x61, 0x71, 0xe2, 0x85, 0x41, 0xbb, 0x86, 0x14, 0xdf, 0x18, 0x66, 0x16, 0xf4, 0xb6, 0x92,
	0x9f, 0x09, 0x74, 0x94, 0x59, 0x4b, 0x72, 0xde, 0x05, 0x46, 0xa8, 0x16, 0x60, 0x3e, 0x85, 0x96,
	0x23, 0x66, 0xdb, 0x75, 0xc2, 0xe0, 0xa5, 0x77, 0xd4, 0xae, 0x23, 0xd1, 0xb7, 0x86, 0x99, 0xd5,
	0x94, 0x9e, 0x0e, 0x3a, 0x46, 0x99, 0xb5, 0x22, 0xb7, 0xb3, 0x0e, 0x13, 0x5a, 0x0e, 0x33, 0xbf,
	0x0f, 0x73, 0x4e, 0xd4, 0xf5, 0x99, 0xed, 0xb2, 0xb8, 0x3d, 0x8b, 0x64, 0xd6, 0x30, 0xb3, 0x66,
	0x9d, 0x68, 0x0f, 0xb1, 0x51, 0x66, 0x2d, 0x48, 0x1e, 0x89, 0x10, 0x5a, 0x38, 0xf9, 0xac, 0x02,
	0x96, 0xfe, 0x2a, 0x8c, 0x7b, 0x5d, 0x27, 0xf0, 0xda, 0x73, 0x6a, 0x56, 0x12, 0xee, 0x04, 0x9e,
	0x9a, 0x95, 0xc2, 0x08, 0xd5, 0x02, 0xcc, 0x0d, 0xa8, 0xfa, 0xf6, 0x21, 0xf3, 0xdb, 0x80, 0xe3,
	0x71, 0xd3, 0x21, 0xa0, 0x36, 0x1d, 0x9a, 0x84, 0x0a, 0xd8, 0xfc, 0x39, 0x2c, 0x79, 0x41, 0x92,
	0xda, 0xbe, 0xdf, 0xed, 0x87, 0x41, 0xd7, 0x3e, 0x62, 0x41, 0xda, 0x6e, 0xe0, 0xe0, 0x6f, 0x0f,
	0x33, 0x6b, 0x41, 0x3a, 0xf7, 0xc3, 0x60, 0x9b, 0xbb, 0x46, 0x99, 0xf5, 0xb9, 0xdc, 0xbb, 0x65,
	0x07, 0xa1, 0xe3, 0xa1, 0xe6, 0x2e, 0x34, 0x5c, 0x96, 0x38, 0xb1, 0x17, 0xa5, 0xfc, 0x3d, 0xcd,
	0x23, 0xe9, 0x37, 0x87, 0x99, 0xa5, 0xc3, 0xa3, 0xcc, 0x32, 0x05, 0xa1, 0x06, 0x12, 0xaa, 0x87,
	0x98, 0x8f, 0x60, 0xde, 0x89, 0x99, 0x9d, 0x32, 0xb7, 0x9b, 0x7a, 0x7d, 0xd6, 0x6e, 0x2a, 0x26,
	0x89, 0xff, 0xd4, 0xc3, 0x73, 0x21, 0x99, 0x34, 0x90, 0x50, 0x3d, 0xc4, 0xdc, 0x86, 0x6a, 0x10,
	0xba, 0x2c, 0x69, 0xb7, 0xf0, 0xa0, 0x2e, 0xe6, 0xfb, 0xfe, 0x20, 0x74, 0x99, 0x3a, 0xa5, 0x18,
	0xa2, 0x16, 0x0c, 0x4d, 0x42, 0x05, 0x4c, 0xfe, 0x3e, 0x0d, 0x2b, 0xf2, 0x98, 0x74, 0x90, 0x99,
	0xb2, 0xd7, 0x03, 0x96, 0xa4, 0xe5, 0x7d, 0x6d, 0x5c, 0x61, 0x5f, 0x3f, 0x81, 0xf9, 0xbe, 0x17,
	0x84, 0x71, 0xbe, 0xb1, 0xc5, 0x51, 0xbe, 0x39, 0xcc, 0xac, 0x12, 0x3e, 0xca, 0xac, 0x65, 0x79,
	0xaa, 0x34, 0x94, 0xd0, 0x52, 0x10, 0x27, 0x8b, 0xec, 0xd4, 0x79, 0x95, 0x93, 0x55, 0x14, 0x99,
	0x8e, 0x2b, 0x32, 0x1d, 0x25, 0xb4, 0x14, 0x64, 0xfe, 0x44, 0x96, 0xda, 0x99, 0x53, 0xab, 0x85,
	0x58, 0x06, 0x5c, 0x3e, 0x2c, 0xe9, 0x94, 0xbd, 0xe6, 0x86, 0x2a, 0xe9, 0x12, 0x20, 0x34, 0x77,
	0x91, 0xdf, 0xcc, 0xc0, 0xd2, 0xc4, 0xe8, 0xcb, 0x15, 0xbc, 0x5f, 0x42, 0xd3, 0x09, 0x83, 0x34,
	0x0e, 0xfd, 0x6e, 0xe4, 0xdb, 0x01, 0x93, 0xb5, 0xd7, 0xd4, 0x5f, 0xa9, 0x38, 0x98, 0x62, 0xd6,
	0x32, 0xf8, 0x29, 0x8f, 0x55, 0xb3, 0xd6, 0x51, 0x42, 0x4b, 0x41, 0xe6, 0x2e, 0xd4, 0xf8, 0xb1,
	0x62, 0x71, 0xbb, 0x72, 0x26, 0x35, 0x96, 0x47, 0x11, 0xa5, 0xca, 0xa3, 0xb0, 0x09, 0x95, 0x0e,
	0xb3, 0x03, 0x35, 0x59, 0x62, 0xc4, 0x02, 0xb6, 0x8a, 0x05, 0xd4, 0x48, 0x9c, 0xbc, 0xd6, 0x34,
	0x8b, 0xcc, 0xb0, 0xc8, 0x48, 0x87, 0x3a, 0xd9, 0xd5, 0x8f, 0x39, 0xd9, 0xb5, 0x4f, 0x71, 0xb2,
	0xeb, 0x57, 0x3d, 0xd9, 0xe4, 0xcf, 0x06, 0x80, 0x5a, 0x4d, 0xb3, 0x03, 0xe0, 0x84, 0x41, 0xc0,
	0x1c, 0xa4, 0x35, 0x54, 0x09, 0x54, 0xa8, 0x2a, 0x81, 0x0a, 0x23, 0x54, 0x0b, 0xe0, 0x0b, 0xe5,
	0x84, 0x83, 0x20, 0x95, 0xaa, 0x04, 0x17, 0x0a, 0x01, 0xb5, 0x50, 0x68, 0x12, 0x2a, 0x60, 0xbe,
	0xed, 0x92, 0x88, 0x39, 0xf2, 0x88, 0xe0, 0xb6, 0xe3, 0xb6, 0xda, 0x76, 0xdc, 0x22, 0x14, 0x41,
	0x62, 0x43, 0x4d, 0x26, 0xfb, 0x02, 0xa0, 0x37, 0x38, 0x64, 0x71, 0xc0, 0x52, 0x96, 0x48, 0x15,
	0x52, 0x6c, 0x91, 0x27, 0x85, 0x47, 0x76, 0xa6, 0xc2, 0xd6, 0x3a, 0x53, 0x81, 0xf1, 0xce, 0xa4,
	0x8c, 0xbf, 0x4e, 0x03, 0xa8, 0xf1, 0xe3, 0x8d, 0xc1, 0xb8, 0x5a, 0x63, 0xd8, 0x82, 0xd9, 0x28,
	0x74, 0xbb, 0x8e, 0xe7, 0xc6, 0xb2, 0xb0, 0xe0, 0x59, 0x8d, 0x42, 0xb7, 0xe3, 0xb9, 0xb1, 0x3a,
	0xab, 0x12, 0x20, 0x34, 0x77, 0xf1, 0xea, 0x9b, 0xb0, 0xf8, 0x8d, 0xe7, 0x30, 0x31, 0xba, 0xa2,
	0xde, 0xb6, 0xc4, 0x25, 0x83, 0x7c, 0xdb, 0x1a, 0x48, 0xa8, 0x1e, 0x62, 0xfe, 0x02, 0x96, 0x84,
	0xd9, 0x75, 0x83, 0xa4, 0xeb, 0x86, 0x7d, 0xdb, 0x0b, 0xa4, 0x66, 0xd8, 0x18, 0x66, 0xd6, 0xa2,
	0x8c, 0xdd, 0x09, 0x92, 0x1d, 0xf4, 0x8d, 0x32, 0x6b, 0xb5, 0xc4, 0x59, 0x78, 0x08, 0x9d, 0x08,
	0x26, 0x2f, 0x8a, 0xba, 0xbc, 0xed, 0xfb, 0xcf, 0xe2, 0x93, 0xeb, 0xaa, 0xcb, 0xe4, 0xf7, 0x46,
	0x51, 0xac, 0xae, 0x91, 0x96, 0xeb, 0x61, 0xa9, 0x1f, 0xf4, 0x17, 0x22, 0x21, 0xf5, 0x42, 0x24,
	0x40, 0x68, 0xee, 0x22, 0x7f, 0x51, 0xf9, 0x28, 0xa1, 0xc6, 0xb7, 0x7d, 0xf4, 0xca, 0x4e, 0xf2,
	0x5c, 0x70, 0xdb, 0x23, 0xa0, 0xb6, 0x3d, 0x9a, 0x84, 0x0a, 0xd8, 0xdc, 0x84, 0x5a, 0xcc, 0xec,
	0xa4, 0x68, 0x34, 0x58, 0x85, 0x04, 0xa2, 0xaa, 0x90, 0xb0, 0x09, 0x95, 0x8e, 0xab, 0x8b, 0xf8,
	0x67, 0xb0, 0x98, 0x37, 0xd9, 0x42, 0x63, 0xdf, 0x2b, 0x29, 0xf8, 0xc9, 0x66, 0x7c, 0x8e, 0x7c,
	0xff, 0xad, 0x01, 0x2b, 0x5c, 0xbe, 0x4f, 0xf0, 0x5e, 0x4a, 0xbb, 0x6f, 0x97, 0xb5, 0xfb, 0x19,
	0x92, 0xe0, 0x83, 0xc2, 0xfd, 0xbf, 0x33, 0x30, 0x9b, 0x87, 0x7f, 0x42, 0xd5, 0xce, 0xab, 0x63,
	0xcc, 0x5c, 0x16, 0xa4, 0x9e, 0xed, 0xcb, 0xe5, 0x17, 0xd5, 0xb1, 0x40, 0xb5, 0xea, 0x58, 0x60,
	0xbc, 0x3a, 0x16, 0x06, 0x17, 0xa9, 0xd1, 0xe0, 0xd0, 0xf7, 0x9c, 0xae, 0x17, 0xc9, 0xb3, 0x87,
	0x22, 0x55, 0x80, 0x8f, 0x23, 0x25, 0x52, 0x73, 0x84, 0xd0, 0xc2, 0xc9, 0xf3, 0x8d, 0x43, 0x3f,
	0x97, 0xed, 0x98, 0x2f, 0xb7, 0x55, 0xbe, 0xdc, 0x22, 0x14, 0xc1, 0xa2, 0xae, 0xd6, 0x2e, 0x50,
	0x57, 0xcd, 0x9b, 0x50, 0x71, 0x92, 0x48, 0xb6, 0x92, 0xcf, 0x86, 0x99, 0xc5, 0xcd, 0x51, 0x66,
	0x81, 0x9c, 0x4e, 0x12, 0x11, 0xca, 0xa1, 0x09, 0x31, 0x38, 0x7b, 0x65, 0x31, 0xc8, 0xf5, 0x7a,
	0x12, 0x75, 0x45, 0x57, 0x9d, 0xd3, 0xf4, 0x7a, 0x12, 0xed, 0xc9, 0xc6, 0xba, 0x50, 0x3c, 0x7d,
	0x4f, 0xf4, 0xd6, 0xc2, 0xc9, 0xf3, 0x88, 0xd9, 0x91, 0x17, 0x06, 0x5d, 0x5d, 0x70, 0x63, 0x1e,
	0x02, 0xcf, 0x39, 0xcc, 0xfc, 0x24, 0x15, 0x20, 0xa1, 0x7a, 0x88, 0x79, 0x1f, 0xe0, 0xd7, 0x61,
	0xc0, 0x24, 0x4f, 0x43, 0x95, 0x12, 0x8e, 0xe6, 0x2c, 0xb2, 0x94, 0x14, 0x10, 0xa1, 0xca, 0x4d,
	0xfe, 0x65, 0xc0, 0x12, 0xb6, 0xd1, 0xeb, 0x15, 0xa4, 0x57, 0xad, 0x50, 0xe6, 0x9e, 0x3c, 0xd8,
	0xe2, 0xeb, 0xf2, 0xf3, 0x92, 0x6e, 0xba, 0xbc, 0x58, 0xfc, 0x9b, 0x01, 0xad, 0xf2, 0xd0, 0x49,
	0xf1, 0x67, 0x7c, 0x3a, 0xf1, 0x37, 0xfd, 0x51, 0xe2, 0x0f, 0xbb, 0x07, 0x1f, 0x73, 0xbd, 0x4d,
	0xe9, 0xea, 0xdd, 0xe3, 0x9d, 0x5c, 0xcd, 0xff, 0x87, 0x64, 0xb0, 0x58, 0x86, 0x2e, 0xd3, 0xa5,
	0x57, 0x50, 0xba, 0x40, 0x0a, 0xc4, 0x05, 0x12, 0xfe, 0x3c, 0x83, 0xc5, 0xe7, 0x11, 0x73, 0x2e,
	0xd2, 0x42, 0xf2, 0xb8, 0x8b, 0xb6, 0x90, 0x09, 0xde, 0x6b, 0x69, 0x21, 0x45, 0x16, 0xe7, 0xb7,
	0x90, 0x3f, 0x19, 0x30, 0x9b, 0x87, 0x5f, 0xae, 0x85, 0x6c, 0x42, 0xad, 0xcf, 0xfa, 0x61, 0x7c,
	0xa2, 0xb7, 0x71, 0x81, 0xa8, 0x4d, 0x29, 0x6c, 0x42, 0xa5, 0xc3, 0xdc, 0x82, 0x8a, 0x13, 0x0d,
	0xe4, 0xf9, 0x5c, 0x28, 0x3e, 0x47, 0xa2, 0x01, 0xa6, 0x2b, 0xca, 0x6f, 0x34, 0xd0, 0xca, 0x6f,
	0x34, 0xe0, 0xe5, 0x37, 0x1a, 0x90, 0x1e, 0xd4, 0x65, 0x18, 0x0a, 0x6d, 0x3f, 0x74, 0x7a, 0xba,
	0xe2, 0x40, 0x40, 0x13, 0xda, 0xdc, 0xe4, 0x42, 0x9b, 0xff, 0x96, 0x95, 0xf9, 0xdc, 0xf9, 0xca,
	0x9c, 0xfc, 0xa1, 0x02, 0x2d, 0xbe, 0x2a, 0xda, 0x5e, 0x7d, 0x0e, 0x2d, 0xa5, 0xf5, 0xb5, 0x55,
	0xba, 0x3d, 0xcc, 0x2c, 0xcd, 0x73, 0x20, 0xd6, 0xeb, 0xb3, 0xf1, 0x4f, 0x85, 0x03, 0x5c, 0xb9,
	0xb1, 0x40, 0xf3, 0xde, 0xe4, 0xb7, 0xe4, 0x65, 0x76, 0xf1, 0x77, 0xa0, 0xee, 0x44, 0x83, 0x6e,
	0xdf, 0xcb, 0x3f, 0xb3, 0xc5, 0x07, 0x5d, 0x34, 0xd8, 0xf7, 0x34, 0x29, 0x25, 0x6c, 0xfe, 0x41,
	0x87, 0x7f, 0x14, 0xa3, 0xec, 0x63, 0xd9, 0x87, 0x8b, 0x51, 0xf6, 0x71, 0x79, 0x94, 0x7d, 0x2c,
	0x47, 0xd9, 0xc7, 0xbc, 0x59, 0x88, 0x77, 0x88, 0x8f, 0xd3, 0xae, 0xcf, 0x04, 0x2a, 0x9e, 0xb8,
	0xa8, 0xbf, 0x75, 0x7c, 0xa8, 0x72, 0xeb, 0x0c, 0xf6, 0xb1, 0x6c, 0xce, 0x3a, 0x03, 0x3e, 0xbd,
	0xcc, 0xc0, 0x13, 0x50, 0xee, 0xbb, 0xef, 0xaa, 0x30, 0xb3, 0xdf, 0xd9, 0xa6, 0xe6, 0x26, 0xd4,
	0x1f, 0x31, 0xdb, 0x4f, 0x5f, 0x9d, 0x98, 0xcd, 0x7c, 0x13, 0xe1, 0x2d, 0xf5, 0xda, 0x6a, 0x6e,
	0x8e, 0xdd, 0x55, 0x93, 0x29, 0x73, 0x0f, 0x9a, 0xa2, 0x92, 0x4b, 0x0d, 0x6b, 0x7e, 0x75, 0xea,
	0x7d, 0x82, 0x7c, 0xe1, 0x6b, 0x5f, 0x9e, 0x72, 0x99, 0xaa, 0xb1, 0x1d, 0x40, 0x43, 0xbb, 0xc2,
	0x9d, 0xe0, 0x2a, 0x55, 0xdd, 0x35, 0x2b, 0xf7, 0x9e, 0x71, 0xeb, 0x4b, 0xa6, 0xcc, 0x1f, 0x01,
	0xec, 0xb2, 0x82, 0x6e, 0xfc, 0xaa, 0x43, 0xe3, 0x3a, 0x27, 0xaf, 0x1d, 0x68, 0xee, 0x30, 0x9f,
	0xa9, 0x59, 0x7e, 0x80, 0xaa, 0x68, 0x90, 0xe5, 0xbb, 0x78, 0x64, 0xa9, 0x6f, 0xbb, 0x2e, 0x2f,
	0xd7, 0x6a, 0xfc, 0x44, 0xa3, 0x5f, 0xfb, 0x4a, 0x9f, 0xd6, 0xb8, 0x1a, 0x26, 0x53, 0xe6, 0x43,
	0x98, 0xcd, 0x3d, 0x65, 0x9a, 0xf2, 0xea, 0x9c, 0x47, 0x73, 0x0f, 0xea, 0xbb, 0x4c, 0xb0, 0x94,
	0x5a, 0xba, 0x46, 0xd1, 0x1e, 0x57, 0xcf, 0xda, 0xf0, 0x1f, 0x00, 0x50, 0xd6, 0x0f, 0xdf, 0xb0,
	0x0f, 0x32, 0x9c, 0xbd, 0x16, 0x0f, 0xc4, 0x2c, 0x78, 0x3d, 0x50, 0xa3, 0xcb, 0xd5, 0xa1, 0x3c,
	0x85, 0xf1, 0xa2, 0x4e, 0xa6, 0x1e, 0x2c, 0xfe, 0xe3, 0xfd, 0xba, 0xf1, 0xcf, 0xf7, 0xeb, 0xc6,
	0xbf, 0xdf, 0xaf, 0x1b, 0x7f, 0xfc, 0xcf, 0xfa, 0xd4, 0x61, 0x0d, 0xff, 0xbd, 0xb2, 0xf9, 0xbf,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x99, 0xf9, 0x54, 0x19, 0x93, 0x19, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MCARClient is the client API for MCAR service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MCARClient interface {
	Healthy(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MessageResponse, error)
	CreateCluster(ctx context.Context, in *ClusterCreateRequest, opts ...grpc.CallOption) (*ClusterInfoResponse, error)
	ListCluster(ctx context.Context, in *ClusterAllQryRequest, opts ...grpc.CallOption) (*ListClusterInfoResponse, error)
	GetCluster(ctx context.Context, in *ClusterQryRequest, opts ...grpc.CallOption) (*ClusterInfoResponse, error)
	DeleteCluster(ctx context.Context, in *ClusterQryRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	AddNode(ctx context.Context, in *NodeCreateRequest, opts ...grpc.CallOption) (*ListNodeInfoResponse, error)
	ListNode(ctx context.Context, in *NodeAllQryRequest, opts ...grpc.CallOption) (*ListNodeInfoResponse, error)
	GetNode(ctx context.Context, in *NodeQryRequest, opts ...grpc.CallOption) (*NodeInfoResponse, error)
	RemoveNode(ctx context.Context, in *NodeQryRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	ListSpec(ctx context.Context, in *SpecQryRequest, opts ...grpc.CallOption) (*ListSpecInfoResponse, error)
}

type mCARClient struct {
	cc *grpc.ClientConn
}

func NewMCARClient(cc *grpc.ClientConn) MCARClient {
	return &mCARClient{cc}
}

func (c *mCARClient) Healthy(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MessageResponse, error) {
	out := new(MessageResponse)
	err := c.cc.Invoke(ctx, "/cbmcks.MCAR/Healthy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mCARClient) CreateCluster(ctx context.Context, in *ClusterCreateRequest, opts ...grpc.CallOption) (*ClusterInfoResponse, error) {
	out := new(ClusterInfoResponse)
	err := c.cc.Invoke(ctx, "/cbmcks.MCAR/CreateCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mCARClient) ListCluster(ctx context.Context, in *ClusterAllQryRequest, opts ...grpc.CallOption) (*ListClusterInfoResponse, error) {
	out := new(ListClusterInfoResponse)
	err := c.cc.Invoke(ctx, "/cbmcks.MCAR/ListCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mCARClient) GetCluster(ctx context.Context, in *ClusterQryRequest, opts ...grpc.CallOption) (*ClusterInfoResponse, error) {
	out := new(ClusterInfoResponse)
	err := c.cc.Invoke(ctx, "/cbmcks.MCAR/GetCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mCARClient) DeleteCluster(ctx context.Context, in *ClusterQryRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, "/cbmcks.MCAR/DeleteCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mCARClient) AddNode(ctx context.Context, in *NodeCreateRequest, opts ...grpc.CallOption) (*ListNodeInfoResponse, error) {
	out := new(ListNodeInfoResponse)
	err := c.cc.Invoke(ctx, "/cbmcks.MCAR/AddNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mCARClient) ListNode(ctx context.Context, in *NodeAllQryRequest, opts ...grpc.CallOption) (*ListNodeInfoResponse, error) {
	out := new(ListNodeInfoResponse)
	err := c.cc.Invoke(ctx, "/cbmcks.MCAR/ListNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mCARClient) GetNode(ctx context.Context, in *NodeQryRequest, opts ...grpc.CallOption) (*NodeInfoResponse, error) {
	out := new(NodeInfoResponse)
	err := c.cc.Invoke(ctx, "/cbmcks.MCAR/GetNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mCARClient) RemoveNode(ctx context.Context, in *NodeQryRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, "/cbmcks.MCAR/RemoveNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mCARClient) ListSpec(ctx context.Context, in *SpecQryRequest, opts ...grpc.CallOption) (*ListSpecInfoResponse, error) {
	out := new(ListSpecInfoResponse)
	err := c.cc.Invoke(ctx, "/cbmcks.MCAR/ListSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MCARServer is the server API for MCAR service.
type MCARServer interface {
	Healthy(context.Context, *Empty) (*MessageResponse, error)
	CreateCluster(context.Context, *ClusterCreateRequest) (*ClusterInfoResponse, error)
	ListCluster(context.Context, *ClusterAllQryRequest) (*ListClusterInfoResponse, error)
	GetCluster(context.Context, *ClusterQryRequest) (*ClusterInfoResponse, error)
	DeleteCluster(context.Context, *ClusterQryRequest) (*StatusResponse, error)
	AddNode(context.Context, *NodeCreateRequest) (*ListNodeInfoResponse, error)
	ListNode(context.Context, *NodeAllQryRequest) (*ListNodeInfoResponse, error)
	GetNode(context.Context, *NodeQryRequest) (*NodeInfoResponse, error)
	RemoveNode(context.Context, *NodeQryRequest) (*StatusResponse, error)
	ListSpec(context.Context, *SpecQryRequest) (*ListSpecInfoResponse, error)
}

// UnimplementedMCARServer can be embedded to have forward compatible implementations.
type UnimplementedMCARServer struct {
}

func (*UnimplementedMCARServer) Healthy(ctx context.Context, req *Empty) (*MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Healthy not implemented")
}
func (*UnimplementedMCARServer) CreateCluster(ctx context.Context, req *ClusterCreateRequest) (*ClusterInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCluster not implemented")
}
func (*UnimplementedMCARServer) ListCluster(ctx context.Context, req *ClusterAllQryRequest) (*ListClusterInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCluster not implemented")
}
func (*UnimplementedMCARServer) GetCluster(ctx context.Context, req *ClusterQryRequest) (*ClusterInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCluster not implemented")
}
func (*UnimplementedMCARServer) DeleteCluster(ctx context.Context, req *ClusterQryRequest) (*StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCluster not implemented")
}
func (*UnimplementedMCARServer) AddNode(ctx context.Context, req *NodeCreateRequest) (*ListNodeInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddNode not implemented")
}
func (*UnimplementedMCARServer) ListNode(ctx context.Context, req *NodeAllQryRequest) (*ListNodeInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNode not implemented")
}
func (*UnimplementedMCARServer) GetNode(ctx context.Context, req *NodeQryRequest) (*NodeInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNode not implemented")
}
func (*UnimplementedMCARServer) RemoveNode(ctx context.Context, req *NodeQryRequest) (*StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveNode not implemented")
}
func (*UnimplementedMCARServer) ListSpec(ctx context.Context, req *SpecQryRequest) (*ListSpecInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSpec not implemented")
}

func RegisterMCARServer(s *grpc.Server, srv MCARServer) {
	s.RegisterService(&_MCAR_serviceDesc, srv)
}

func _MCAR_Healthy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MCARServer).Healthy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbmcks.MCAR/Healthy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MCARServer).Healthy(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MCAR_CreateCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MCARServer).CreateCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbmcks.MCAR/CreateCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MCARServer).CreateCluster(ctx, req.(*ClusterCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MCAR_ListCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterAllQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MCARServer).ListCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbmcks.MCAR/ListCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MCARServer).ListCluster(ctx, req.(*ClusterAllQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MCAR_GetCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MCARServer).GetCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbmcks.MCAR/GetCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MCARServer).GetCluster(ctx, req.(*ClusterQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MCAR_DeleteCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MCARServer).DeleteCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbmcks.MCAR/DeleteCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MCARServer).DeleteCluster(ctx, req.(*ClusterQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MCAR_AddNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MCARServer).AddNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbmcks.MCAR/AddNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MCARServer).AddNode(ctx, req.(*NodeCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MCAR_ListNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeAllQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MCARServer).ListNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbmcks.MCAR/ListNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MCARServer).ListNode(ctx, req.(*NodeAllQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MCAR_GetNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MCARServer).GetNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbmcks.MCAR/GetNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MCARServer).GetNode(ctx, req.(*NodeQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MCAR_RemoveNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MCARServer).RemoveNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbmcks.MCAR/RemoveNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MCARServer).RemoveNode(ctx, req.(*NodeQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MCAR_ListSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpecQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MCARServer).ListSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbmcks.MCAR/ListSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MCARServer).ListSpec(ctx, req.(*SpecQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _MCAR_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cbmcks.MCAR",
	HandlerType: (*MCARServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Healthy",
			Handler:    _MCAR_Healthy_Handler,
		},
		{
			MethodName: "CreateCluster",
			Handler:    _MCAR_CreateCluster_Handler,
		},
		{
			MethodName: "ListCluster",
			Handler:    _MCAR_ListCluster_Handler,
		},
		{
			MethodName: "GetCluster",
			Handler:    _MCAR_GetCluster_Handler,
		},
		{
			MethodName: "DeleteCluster",
			Handler:    _MCAR_DeleteCluster_Handler,
		},
		{
			MethodName: "AddNode",
			Handler:    _MCAR_AddNode_Handler,
		},
		{
			MethodName: "ListNode",
			Handler:    _MCAR_ListNode_Handler,
		},
		{
			MethodName: "GetNode",
			Handler:    _MCAR_GetNode_Handler,
		},
		{
			MethodName: "RemoveNode",
			Handler:    _MCAR_RemoveNode_Handler,
		},
		{
			MethodName: "ListSpec",
			Handler:    _MCAR_ListSpec_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cbmcks/cbmcks.proto",
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *MessageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintCbmcks(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbmcks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListClusterInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListClusterInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListClusterInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbmcks(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbmcks(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.CreatedTime) > 0 {
		i -= len(m.CreatedTime)
		copy(dAtA[i:], m.CreatedTime)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.CreatedTime)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.InstallMonAgent) > 0 {
		i -= len(m.InstallMonAgent)
		copy(dAtA[i:], m.InstallMonAgent)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.InstallMonAgent)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.NetworkCni) > 0 {
		i -= len(m.NetworkCni)
		copy(dAtA[i:], m.NetworkCni)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.NetworkCni)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.CpLeader) > 0 {
		i -= len(m.CpLeader)
		copy(dAtA[i:], m.CpLeader)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.CpLeader)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ClusterConfig) > 0 {
		i -= len(m.ClusterConfig)
		copy(dAtA[i:], m.ClusterConfig)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.ClusterConfig)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.K8SVersion) > 0 {
		i -= len(m.K8SVersion)
		copy(dAtA[i:], m.K8SVersion)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.K8SVersion)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Mcis) > 0 {
		i -= len(m.Mcis)
		copy(dAtA[i:], m.Mcis)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Mcis)))
		i--
		dAtA[i] = 0x22
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbmcks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterCreateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterCreateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterCreateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbmcks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Patchversion) > 0 {
		i -= len(m.Patchversion)
		copy(dAtA[i:], m.Patchversion)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Patchversion)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Minorversion) > 0 {
		i -= len(m.Minorversion)
		copy(dAtA[i:], m.Minorversion)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Minorversion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterCreateInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterCreateInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterCreateInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.InstallMonAgent) > 0 {
		i -= len(m.InstallMonAgent)
		copy(dAtA[i:], m.InstallMonAgent)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.InstallMonAgent)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Config != nil {
		{
			size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbmcks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Worker) > 0 {
		for iNdEx := len(m.Worker) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Worker[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbmcks(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ControlPlane) > 0 {
		for iNdEx := len(m.ControlPlane) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ControlPlane[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbmcks(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Spec) > 0 {
		i -= len(m.Spec)
		copy(dAtA[i:], m.Spec)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Spec)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Count != 0 {
		i = encodeVarintCbmcks(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Connection) > 0 {
		i -= len(m.Connection)
		copy(dAtA[i:], m.Connection)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Connection)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Kubernetes != nil {
		{
			size, err := m.Kubernetes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbmcks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Kubernetes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Kubernetes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Kubernetes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ServicDnsDomain) > 0 {
		i -= len(m.ServicDnsDomain)
		copy(dAtA[i:], m.ServicDnsDomain)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.ServicDnsDomain)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ServiceCidr) > 0 {
		i -= len(m.ServiceCidr)
		copy(dAtA[i:], m.ServiceCidr)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.ServiceCidr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PodCidr) > 0 {
		i -= len(m.PodCidr)
		copy(dAtA[i:], m.PodCidr)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.PodCidr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NetworkCni) > 0 {
		i -= len(m.NetworkCni)
		copy(dAtA[i:], m.NetworkCni)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.NetworkCni)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterAllQryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterAllQryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterAllQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterQryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterQryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cluster) > 0 {
		i -= len(m.Cluster)
		copy(dAtA[i:], m.Cluster)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Cluster)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterStatusInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterStatusInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterStatusInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Phase) > 0 {
		i -= len(m.Phase)
		copy(dAtA[i:], m.Phase)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Phase)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbmcks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListNodeInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListNodeInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListNodeInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbmcks(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ZoneLabel) > 0 {
		i -= len(m.ZoneLabel)
		copy(dAtA[i:], m.ZoneLabel)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.ZoneLabel)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.RegionLabel) > 0 {
		i -= len(m.RegionLabel)
		copy(dAtA[i:], m.RegionLabel)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.RegionLabel)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.CspLabel) > 0 {
		i -= len(m.CspLabel)
		copy(dAtA[i:], m.CspLabel)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.CspLabel)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.CreatedTime) > 0 {
		i -= len(m.CreatedTime)
		copy(dAtA[i:], m.CreatedTime)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.CreatedTime)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Csp) > 0 {
		i -= len(m.Csp)
		copy(dAtA[i:], m.Csp)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Csp)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Spec) > 0 {
		i -= len(m.Spec)
		copy(dAtA[i:], m.Spec)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Spec)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PublicIp) > 0 {
		i -= len(m.PublicIp)
		copy(dAtA[i:], m.PublicIp)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.PublicIp)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Credential) > 0 {
		i -= len(m.Credential)
		copy(dAtA[i:], m.Credential)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Credential)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeCreateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeCreateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeCreateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbmcks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Cluster) > 0 {
		i -= len(m.Cluster)
		copy(dAtA[i:], m.Cluster)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Cluster)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeCreateInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeCreateInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeCreateInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Worker) > 0 {
		for iNdEx := len(m.Worker) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Worker[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbmcks(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ControlPlane) > 0 {
		for iNdEx := len(m.ControlPlane) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ControlPlane[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbmcks(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NodeAllQryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeAllQryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeAllQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cluster) > 0 {
		i -= len(m.Cluster)
		copy(dAtA[i:], m.Cluster)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Cluster)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeQryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeQryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Node) > 0 {
		i -= len(m.Node)
		copy(dAtA[i:], m.Node)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Node)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Cluster) > 0 {
		i -= len(m.Cluster)
		copy(dAtA[i:], m.Cluster)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Cluster)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpecInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpecInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpecInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbmcks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListSpecInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListSpecInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListSpecInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbmcks(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpecInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpecInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpecInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Cpu != nil {
		{
			size, err := m.Cpu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbmcks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Memory) > 0 {
		i -= len(m.Memory)
		copy(dAtA[i:], m.Memory)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Memory)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CpuInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CpuInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CpuInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Count) > 0 {
		i -= len(m.Count)
		copy(dAtA[i:], m.Count)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Count)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Clock) > 0 {
		i -= len(m.Clock)
		copy(dAtA[i:], m.Clock)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Clock)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpecQryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpecQryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpecQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MemoryMax) > 0 {
		i -= len(m.MemoryMax)
		copy(dAtA[i:], m.MemoryMax)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.MemoryMax)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.MemoryMin) > 0 {
		i -= len(m.MemoryMin)
		copy(dAtA[i:], m.MemoryMin)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.MemoryMin)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CpuMax) > 0 {
		i -= len(m.CpuMax)
		copy(dAtA[i:], m.CpuMax)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.CpuMax)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CpuMin) > 0 {
		i -= len(m.CpuMin)
		copy(dAtA[i:], m.CpuMin)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.CpuMin)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ControlPlane) > 0 {
		i -= len(m.ControlPlane)
		copy(dAtA[i:], m.ControlPlane)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.ControlPlane)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Connectionname) > 0 {
		i -= len(m.Connectionname)
		copy(dAtA[i:], m.Connectionname)
		i = encodeVarintCbmcks(dAtA, i, uint64(len(m.Connectionname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCbmcks(dAtA []byte, offset int, v uint64) int {
	offset -= sovCbmcks(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovCbmcks(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListClusterInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovCbmcks(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.Mcis)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.K8SVersion)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.ClusterConfig)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.CpLeader)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.NetworkCni)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.InstallMonAgent)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.CreatedTime)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovCbmcks(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterCreateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.Minorversion)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.Patchversion)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterCreateInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if len(m.ControlPlane) > 0 {
		for _, e := range m.ControlPlane {
			l = e.Size()
			n += 1 + l + sovCbmcks(uint64(l))
		}
	}
	if len(m.Worker) > 0 {
		for _, e := range m.Worker {
			l = e.Size()
			n += 1 + l + sovCbmcks(uint64(l))
		}
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.InstallMonAgent)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Connection)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovCbmcks(uint64(m.Count))
	}
	l = len(m.Spec)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kubernetes != nil {
		l = m.Kubernetes.Size()
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Kubernetes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NetworkCni)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.PodCidr)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.ServiceCidr)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.ServicDnsDomain)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterAllQryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterQryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.Cluster)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterStatusInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Phase)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListNodeInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovCbmcks(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.Credential)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.PublicIp)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.Spec)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.Csp)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.CreatedTime)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.CspLabel)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.RegionLabel)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.ZoneLabel)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeCreateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.Cluster)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeCreateInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ControlPlane) > 0 {
		for _, e := range m.ControlPlane {
			l = e.Size()
			n += 1 + l + sovCbmcks(uint64(l))
		}
	}
	if len(m.Worker) > 0 {
		for _, e := range m.Worker {
			l = e.Size()
			n += 1 + l + sovCbmcks(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeAllQryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.Cluster)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeQryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.Cluster)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.Node)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SpecInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListSpecInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovCbmcks(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SpecInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.Memory)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.Cpu != nil {
		l = m.Cpu.Size()
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CpuInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Clock)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.Count)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SpecQryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Connectionname)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.ControlPlane)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.CpuMin)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.CpuMax)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.MemoryMin)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	l = len(m.MemoryMax)
	if l > 0 {
		n += 1 + l + sovCbmcks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCbmcks(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCbmcks(x uint64) (n int) {
	return sovCbmcks(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Item == nil {
				m.Item = &ClusterInfo{}
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListClusterInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListClusterInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListClusterInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ClusterInfo{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &ClusterStatusInfo{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mcis", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mcis = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.K8SVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpLeader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpLeader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkCni", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkCni = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstallMonAgent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstallMonAgent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &NodeInfo{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterCreateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterCreateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterCreateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minorversion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Minorversion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Patchversion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Patchversion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Item == nil {
				m.Item = &ClusterCreateInfo{}
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterCreateInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterCreateInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterCreateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlPlane", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ControlPlane = append(m.ControlPlane, &NodeConfig{})
			if err := m.ControlPlane[len(m.ControlPlane)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Worker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Worker = append(m.Worker, &NodeConfig{})
			if err := m.Worker[len(m.Worker)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &Config{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstallMonAgent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstallMonAgent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connection", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Connection = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kubernetes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kubernetes == nil {
				m.Kubernetes = &Kubernetes{}
			}
			if err := m.Kubernetes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Kubernetes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Kubernetes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Kubernetes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkCni", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkCni = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodCidr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodCidr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceCidr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceCidr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServicDnsDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServicDnsDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterAllQryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterAllQryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterAllQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterQryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterQryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterStatusInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterStatusInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterStatusInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Item == nil {
				m.Item = &NodeInfo{}
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListNodeInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListNodeInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListNodeInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &NodeInfo{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credential", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credential = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Csp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Csp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CspLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CspLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZoneLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ZoneLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeCreateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeCreateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeCreateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Item == nil {
				m.Item = &NodeCreateInfo{}
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeCreateInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeCreateInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeCreateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlPlane", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ControlPlane = append(m.ControlPlane, &NodeConfig{})
			if err := m.ControlPlane[len(m.ControlPlane)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Worker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Worker = append(m.Worker, &NodeConfig{})
			if err := m.Worker[len(m.Worker)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeAllQryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeAllQryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeAllQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeQryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeQryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpecInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpecInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpecInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Item == nil {
				m.Item = &SpecInfo{}
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListSpecInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListSpecInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListSpecInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &SpecInfo{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpecInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpecInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpecInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memory = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cpu == nil {
				m.Cpu = &CpuInfo{}
			}
			if err := m.Cpu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CpuInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CpuInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CpuInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clock", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clock = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Count = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpecQryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpecQryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpecQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connectionname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Connectionname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlPlane", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ControlPlane = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuMin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuMin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuMax", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuMax = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryMin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MemoryMin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryMax", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbmcks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbmcks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MemoryMax = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbmcks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbmcks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCbmcks(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCbmcks
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCbmcks
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCbmcks
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCbmcks
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCbmcks
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCbmcks        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCbmcks          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCbmcks = fmt.Errorf("proto: unexpected end of group")
)
