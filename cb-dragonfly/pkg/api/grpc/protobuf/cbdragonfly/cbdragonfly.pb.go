// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cbdragonfly/cbdragonfly.proto

package cbdragonfly

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/cloud-barista/cb-spider/api-runtime/grpc-runtime/stub/gogoproto"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Empty 메시지 정의
type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{0}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

// MessageResponse 응답 메시지 정의
type MessageResponse struct {
	Message              string   `protobuf:"bytes,1,opt,name=message,proto3" json:"message" yaml:"message"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageResponse) Reset()         { *m = MessageResponse{} }
func (m *MessageResponse) String() string { return proto.CompactTextString(m) }
func (*MessageResponse) ProtoMessage()    {}
func (*MessageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{1}
}
func (m *MessageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageResponse.Merge(m, src)
}
func (m *MessageResponse) XXX_Size() int {
	return m.Size()
}
func (m *MessageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MessageResponse proto.InternalMessageInfo

func (m *MessageResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type Tags struct {
	//	string host_id = 1 [json_name="hostId", (gogoproto.jsontag) = "hostId", (gogoproto.moretags) = "yaml:\"hostId\""];
	NsId                 string   `protobuf:"bytes,1,opt,name=ns_id,json=nsId,proto3" json:"nsId" yaml:"nsId"`
	McisId               string   `protobuf:"bytes,2,opt,name=mcis_id,json=mcisId,proto3" json:"mcisId" yaml:"mcisId"`
	VmId                 string   `protobuf:"bytes,3,opt,name=vm_id,json=vmId,proto3" json:"vmId" yaml:"vmId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tags) Reset()         { *m = Tags{} }
func (m *Tags) String() string { return proto.CompactTextString(m) }
func (*Tags) ProtoMessage()    {}
func (*Tags) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{2}
}
func (m *Tags) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tags) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tags.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tags) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tags.Merge(m, src)
}
func (m *Tags) XXX_Size() int {
	return m.Size()
}
func (m *Tags) XXX_DiscardUnknown() {
	xxx_messageInfo_Tags.DiscardUnknown(m)
}

var xxx_messageInfo_Tags proto.InternalMessageInfo

func (m *Tags) GetNsId() string {
	if m != nil {
		return m.NsId
	}
	return ""
}

func (m *Tags) GetMcisId() string {
	if m != nil {
		return m.McisId
	}
	return ""
}

func (m *Tags) GetVmId() string {
	if m != nil {
		return m.VmId
	}
	return ""
}

type VMMonQryRequest struct {
	NsId                 string   `protobuf:"bytes,1,opt,name=ns_id,proto3" json:"ns_id" yaml:"ns_id"`
	McisId               string   `protobuf:"bytes,2,opt,name=mcis_id,proto3" json:"mcis_id" yaml:"mcis_id"`
	VmId                 string   `protobuf:"bytes,3,opt,name=vm_id,proto3" json:"vm_id" yaml:"vm_id"`
	PeriodType           string   `protobuf:"bytes,4,opt,name=period_type,json=periodType,proto3" json:"periodType" yaml:"periodType"`
	StatisticsCriteria   string   `protobuf:"bytes,5,opt,name=statistics_criteria,json=statisticsCriteria,proto3" json:"statisticsCriteria" yaml:"statisticsCriteria"`
	Duration             string   `protobuf:"bytes,6,opt,name=duration,proto3" json:"duration" yaml:"duration"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VMMonQryRequest) Reset()         { *m = VMMonQryRequest{} }
func (m *VMMonQryRequest) String() string { return proto.CompactTextString(m) }
func (*VMMonQryRequest) ProtoMessage()    {}
func (*VMMonQryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{3}
}
func (m *VMMonQryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VMMonQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VMMonQryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VMMonQryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VMMonQryRequest.Merge(m, src)
}
func (m *VMMonQryRequest) XXX_Size() int {
	return m.Size()
}
func (m *VMMonQryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VMMonQryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VMMonQryRequest proto.InternalMessageInfo

func (m *VMMonQryRequest) GetNsId() string {
	if m != nil {
		return m.NsId
	}
	return ""
}

func (m *VMMonQryRequest) GetMcisId() string {
	if m != nil {
		return m.McisId
	}
	return ""
}

func (m *VMMonQryRequest) GetVmId() string {
	if m != nil {
		return m.VmId
	}
	return ""
}

func (m *VMMonQryRequest) GetPeriodType() string {
	if m != nil {
		return m.PeriodType
	}
	return ""
}

func (m *VMMonQryRequest) GetStatisticsCriteria() string {
	if m != nil {
		return m.StatisticsCriteria
	}
	return ""
}

func (m *VMMonQryRequest) GetDuration() string {
	if m != nil {
		return m.Duration
	}
	return ""
}

type VMOnDemandMonQryRequest struct {
	NsId                 string   `protobuf:"bytes,1,opt,name=ns_id,proto3" json:"ns_id" yaml:"ns_id"`
	McisId               string   `protobuf:"bytes,2,opt,name=mcis_id,proto3" json:"mcis_id" yaml:"mcis_id"`
	VmId                 string   `protobuf:"bytes,3,opt,name=vm_id,proto3" json:"vm_id" yaml:"vm_id"`
	AgentIp              string   `protobuf:"bytes,4,opt,name=agent_ip,proto3" json:"agent_ip" yaml:"agent_ip"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VMOnDemandMonQryRequest) Reset()         { *m = VMOnDemandMonQryRequest{} }
func (m *VMOnDemandMonQryRequest) String() string { return proto.CompactTextString(m) }
func (*VMOnDemandMonQryRequest) ProtoMessage()    {}
func (*VMOnDemandMonQryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{4}
}
func (m *VMOnDemandMonQryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VMOnDemandMonQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VMOnDemandMonQryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VMOnDemandMonQryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VMOnDemandMonQryRequest.Merge(m, src)
}
func (m *VMOnDemandMonQryRequest) XXX_Size() int {
	return m.Size()
}
func (m *VMOnDemandMonQryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VMOnDemandMonQryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VMOnDemandMonQryRequest proto.InternalMessageInfo

func (m *VMOnDemandMonQryRequest) GetNsId() string {
	if m != nil {
		return m.NsId
	}
	return ""
}

func (m *VMOnDemandMonQryRequest) GetMcisId() string {
	if m != nil {
		return m.McisId
	}
	return ""
}

func (m *VMOnDemandMonQryRequest) GetVmId() string {
	if m != nil {
		return m.VmId
	}
	return ""
}

func (m *VMOnDemandMonQryRequest) GetAgentIp() string {
	if m != nil {
		return m.AgentIp
	}
	return ""
}

type VMMCISMonQryRequest struct {
	NsId                 string   `protobuf:"bytes,1,opt,name=ns_id,proto3" json:"ns_id" yaml:"ns_id"`
	McisId               string   `protobuf:"bytes,2,opt,name=mcis_id,proto3" json:"mcis_id" yaml:"mcis_id"`
	VmId                 string   `protobuf:"bytes,3,opt,name=vm_id,proto3" json:"vm_id" yaml:"vm_id"`
	AgentIp              string   `protobuf:"bytes,4,opt,name=agent_ip,proto3" json:"agent_ip" yaml:"agent_ip"`
	MetricName           string   `protobuf:"bytes,5,opt,name=metric_name,proto3" json:"metric_name" yaml:"metric_name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VMMCISMonQryRequest) Reset()         { *m = VMMCISMonQryRequest{} }
func (m *VMMCISMonQryRequest) String() string { return proto.CompactTextString(m) }
func (*VMMCISMonQryRequest) ProtoMessage()    {}
func (*VMMCISMonQryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{5}
}
func (m *VMMCISMonQryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VMMCISMonQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VMMCISMonQryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VMMCISMonQryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VMMCISMonQryRequest.Merge(m, src)
}
func (m *VMMCISMonQryRequest) XXX_Size() int {
	return m.Size()
}
func (m *VMMCISMonQryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VMMCISMonQryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VMMCISMonQryRequest proto.InternalMessageInfo

func (m *VMMCISMonQryRequest) GetNsId() string {
	if m != nil {
		return m.NsId
	}
	return ""
}

func (m *VMMCISMonQryRequest) GetMcisId() string {
	if m != nil {
		return m.McisId
	}
	return ""
}

func (m *VMMCISMonQryRequest) GetVmId() string {
	if m != nil {
		return m.VmId
	}
	return ""
}

func (m *VMMCISMonQryRequest) GetAgentIp() string {
	if m != nil {
		return m.AgentIp
	}
	return ""
}

func (m *VMMCISMonQryRequest) GetMetricName() string {
	if m != nil {
		return m.MetricName
	}
	return ""
}

type CpuOnDemandInfoResponse struct {
	Name                 string           `protobuf:"bytes,1,opt,name=name,proto3" json:"name" yaml:"name"`
	Tags                 *Tags            `protobuf:"bytes,2,opt,name=tags,proto3" json:"tags" yaml:"tags"`
	Time                 string           `protobuf:"bytes,3,opt,name=time,proto3" json:"time" yaml:"time"`
	Values               *CpuOnDemandInfo `protobuf:"bytes,4,opt,name=values,proto3" json:"values" yaml:"values"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *CpuOnDemandInfoResponse) Reset()         { *m = CpuOnDemandInfoResponse{} }
func (m *CpuOnDemandInfoResponse) String() string { return proto.CompactTextString(m) }
func (*CpuOnDemandInfoResponse) ProtoMessage()    {}
func (*CpuOnDemandInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{6}
}
func (m *CpuOnDemandInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CpuOnDemandInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CpuOnDemandInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CpuOnDemandInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CpuOnDemandInfoResponse.Merge(m, src)
}
func (m *CpuOnDemandInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *CpuOnDemandInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CpuOnDemandInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CpuOnDemandInfoResponse proto.InternalMessageInfo

func (m *CpuOnDemandInfoResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CpuOnDemandInfoResponse) GetTags() *Tags {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *CpuOnDemandInfoResponse) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

func (m *CpuOnDemandInfoResponse) GetValues() *CpuOnDemandInfo {
	if m != nil {
		return m.Values
	}
	return nil
}

type CpuOnDemandInfo struct {
	CpuUtilization       float64  `protobuf:"fixed64,1,opt,name=cpu_utilization,proto3" json:"cpu_utilization" yaml:"cpu_utilization"`
	CpuSystem            float64  `protobuf:"fixed64,2,opt,name=cpu_system,proto3" json:"cpu_system" yaml:"cpu_system"`
	CpuIdle              float64  `protobuf:"fixed64,3,opt,name=cpu_idle,proto3" json:"cpu_idle" yaml:"cpu_idle"`
	CpuIowait            float64  `protobuf:"fixed64,4,opt,name=cpu_iowait,proto3" json:"cpu_iowait" yaml:"cpu_iowait"`
	CpuHintr             float64  `protobuf:"fixed64,5,opt,name=cpu_hintr,proto3" json:"cpu_hintr" yaml:"cpu_hintr"`
	CpuSintr             float64  `protobuf:"fixed64,6,opt,name=cpu_sintr,proto3" json:"cpu_sintr" yaml:"cpu_sintr"`
	CpuUser              float64  `protobuf:"fixed64,7,opt,name=cpu_user,proto3" json:"cpu_user" yaml:"cpu_user"`
	CpuNice              float64  `protobuf:"fixed64,8,opt,name=cpu_nice,proto3" json:"cpu_nice" yaml:"cpu_nice"`
	CpuSteal             float64  `protobuf:"fixed64,9,opt,name=cpu_steal,proto3" json:"cpu_steal" yaml:"cpu_steal"`
	CpuGuest             float64  `protobuf:"fixed64,10,opt,name=cpu_guest,proto3" json:"cpu_guest" yaml:"cpu_guest"`
	CpuGuestNice         float64  `protobuf:"fixed64,11,opt,name=cpu_guest_nice,proto3" json:"cpu_guest_nice" yaml:"cpu_guest_nice"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CpuOnDemandInfo) Reset()         { *m = CpuOnDemandInfo{} }
func (m *CpuOnDemandInfo) String() string { return proto.CompactTextString(m) }
func (*CpuOnDemandInfo) ProtoMessage()    {}
func (*CpuOnDemandInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{7}
}
func (m *CpuOnDemandInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CpuOnDemandInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CpuOnDemandInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CpuOnDemandInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CpuOnDemandInfo.Merge(m, src)
}
func (m *CpuOnDemandInfo) XXX_Size() int {
	return m.Size()
}
func (m *CpuOnDemandInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CpuOnDemandInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CpuOnDemandInfo proto.InternalMessageInfo

func (m *CpuOnDemandInfo) GetCpuUtilization() float64 {
	if m != nil {
		return m.CpuUtilization
	}
	return 0
}

func (m *CpuOnDemandInfo) GetCpuSystem() float64 {
	if m != nil {
		return m.CpuSystem
	}
	return 0
}

func (m *CpuOnDemandInfo) GetCpuIdle() float64 {
	if m != nil {
		return m.CpuIdle
	}
	return 0
}

func (m *CpuOnDemandInfo) GetCpuIowait() float64 {
	if m != nil {
		return m.CpuIowait
	}
	return 0
}

func (m *CpuOnDemandInfo) GetCpuHintr() float64 {
	if m != nil {
		return m.CpuHintr
	}
	return 0
}

func (m *CpuOnDemandInfo) GetCpuSintr() float64 {
	if m != nil {
		return m.CpuSintr
	}
	return 0
}

func (m *CpuOnDemandInfo) GetCpuUser() float64 {
	if m != nil {
		return m.CpuUser
	}
	return 0
}

func (m *CpuOnDemandInfo) GetCpuNice() float64 {
	if m != nil {
		return m.CpuNice
	}
	return 0
}

func (m *CpuOnDemandInfo) GetCpuSteal() float64 {
	if m != nil {
		return m.CpuSteal
	}
	return 0
}

func (m *CpuOnDemandInfo) GetCpuGuest() float64 {
	if m != nil {
		return m.CpuGuest
	}
	return 0
}

func (m *CpuOnDemandInfo) GetCpuGuestNice() float64 {
	if m != nil {
		return m.CpuGuestNice
	}
	return 0
}

type CpuFreqOnDemandInfoResponse struct {
	Name                 string               `protobuf:"bytes,1,opt,name=name,proto3" json:"name" yaml:"name"`
	Tags                 *Tags                `protobuf:"bytes,2,opt,name=tags,proto3" json:"tags" yaml:"tags"`
	Time                 string               `protobuf:"bytes,3,opt,name=time,proto3" json:"time" yaml:"time"`
	Values               *CpuFreqOnDemandInfo `protobuf:"bytes,4,opt,name=values,proto3" json:"values" yaml:"values"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *CpuFreqOnDemandInfoResponse) Reset()         { *m = CpuFreqOnDemandInfoResponse{} }
func (m *CpuFreqOnDemandInfoResponse) String() string { return proto.CompactTextString(m) }
func (*CpuFreqOnDemandInfoResponse) ProtoMessage()    {}
func (*CpuFreqOnDemandInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{8}
}
func (m *CpuFreqOnDemandInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CpuFreqOnDemandInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CpuFreqOnDemandInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CpuFreqOnDemandInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CpuFreqOnDemandInfoResponse.Merge(m, src)
}
func (m *CpuFreqOnDemandInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *CpuFreqOnDemandInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CpuFreqOnDemandInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CpuFreqOnDemandInfoResponse proto.InternalMessageInfo

func (m *CpuFreqOnDemandInfoResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CpuFreqOnDemandInfoResponse) GetTags() *Tags {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *CpuFreqOnDemandInfoResponse) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

func (m *CpuFreqOnDemandInfoResponse) GetValues() *CpuFreqOnDemandInfo {
	if m != nil {
		return m.Values
	}
	return nil
}

type CpuFreqOnDemandInfo struct {
	CpuSpeed             float64  `protobuf:"fixed64,1,opt,name=cpu_speed,proto3" json:"cpu_speed" yaml:"cpu_speed"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CpuFreqOnDemandInfo) Reset()         { *m = CpuFreqOnDemandInfo{} }
func (m *CpuFreqOnDemandInfo) String() string { return proto.CompactTextString(m) }
func (*CpuFreqOnDemandInfo) ProtoMessage()    {}
func (*CpuFreqOnDemandInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{9}
}
func (m *CpuFreqOnDemandInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CpuFreqOnDemandInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CpuFreqOnDemandInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CpuFreqOnDemandInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CpuFreqOnDemandInfo.Merge(m, src)
}
func (m *CpuFreqOnDemandInfo) XXX_Size() int {
	return m.Size()
}
func (m *CpuFreqOnDemandInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CpuFreqOnDemandInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CpuFreqOnDemandInfo proto.InternalMessageInfo

func (m *CpuFreqOnDemandInfo) GetCpuSpeed() float64 {
	if m != nil {
		return m.CpuSpeed
	}
	return 0
}

type MemoryOnDemandInfoResponse struct {
	Name                 string              `protobuf:"bytes,1,opt,name=name,proto3" json:"name" yaml:"name"`
	Tags                 *Tags               `protobuf:"bytes,2,opt,name=tags,proto3" json:"tags" yaml:"tags"`
	Time                 string              `protobuf:"bytes,3,opt,name=time,proto3" json:"time" yaml:"time"`
	Values               *MemoryOnDemandInfo `protobuf:"bytes,4,opt,name=values,proto3" json:"values" yaml:"values"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *MemoryOnDemandInfoResponse) Reset()         { *m = MemoryOnDemandInfoResponse{} }
func (m *MemoryOnDemandInfoResponse) String() string { return proto.CompactTextString(m) }
func (*MemoryOnDemandInfoResponse) ProtoMessage()    {}
func (*MemoryOnDemandInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{10}
}
func (m *MemoryOnDemandInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoryOnDemandInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoryOnDemandInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoryOnDemandInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoryOnDemandInfoResponse.Merge(m, src)
}
func (m *MemoryOnDemandInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *MemoryOnDemandInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoryOnDemandInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MemoryOnDemandInfoResponse proto.InternalMessageInfo

func (m *MemoryOnDemandInfoResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MemoryOnDemandInfoResponse) GetTags() *Tags {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *MemoryOnDemandInfoResponse) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

func (m *MemoryOnDemandInfoResponse) GetValues() *MemoryOnDemandInfo {
	if m != nil {
		return m.Values
	}
	return nil
}

type MemoryOnDemandInfo struct {
	MemUtilization       float64  `protobuf:"fixed64,1,opt,name=mem_utilization,proto3" json:"mem_utilization" yaml:"mem_utilization"`
	MemTotal             float64  `protobuf:"fixed64,2,opt,name=mem_total,proto3" json:"mem_total" yaml:"mem_total"`
	MemUsed              float64  `protobuf:"fixed64,3,opt,name=mem_used,proto3" json:"mem_used" yaml:"mem_used"`
	MemFree              float64  `protobuf:"fixed64,4,opt,name=mem_free,proto3" json:"mem_free" yaml:"mem_free"`
	MemShared            float64  `protobuf:"fixed64,5,opt,name=mem_shared,proto3" json:"mem_shared" yaml:"mem_shared"`
	MemBuffers           float64  `protobuf:"fixed64,6,opt,name=mem_buffers,proto3" json:"mem_buffers" yaml:"mem_buffers"`
	MemCached            float64  `protobuf:"fixed64,7,opt,name=mem_cached,proto3" json:"mem_cached" yaml:"mem_cached"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MemoryOnDemandInfo) Reset()         { *m = MemoryOnDemandInfo{} }
func (m *MemoryOnDemandInfo) String() string { return proto.CompactTextString(m) }
func (*MemoryOnDemandInfo) ProtoMessage()    {}
func (*MemoryOnDemandInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{11}
}
func (m *MemoryOnDemandInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoryOnDemandInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoryOnDemandInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoryOnDemandInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoryOnDemandInfo.Merge(m, src)
}
func (m *MemoryOnDemandInfo) XXX_Size() int {
	return m.Size()
}
func (m *MemoryOnDemandInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoryOnDemandInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MemoryOnDemandInfo proto.InternalMessageInfo

func (m *MemoryOnDemandInfo) GetMemUtilization() float64 {
	if m != nil {
		return m.MemUtilization
	}
	return 0
}

func (m *MemoryOnDemandInfo) GetMemTotal() float64 {
	if m != nil {
		return m.MemTotal
	}
	return 0
}

func (m *MemoryOnDemandInfo) GetMemUsed() float64 {
	if m != nil {
		return m.MemUsed
	}
	return 0
}

func (m *MemoryOnDemandInfo) GetMemFree() float64 {
	if m != nil {
		return m.MemFree
	}
	return 0
}

func (m *MemoryOnDemandInfo) GetMemShared() float64 {
	if m != nil {
		return m.MemShared
	}
	return 0
}

func (m *MemoryOnDemandInfo) GetMemBuffers() float64 {
	if m != nil {
		return m.MemBuffers
	}
	return 0
}

func (m *MemoryOnDemandInfo) GetMemCached() float64 {
	if m != nil {
		return m.MemCached
	}
	return 0
}

type DiskOnDemandInfoResponse struct {
	Name                 string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name" yaml:"name"`
	Tags                 *Tags             `protobuf:"bytes,2,opt,name=tags,proto3" json:"tags" yaml:"tags"`
	Time                 string            `protobuf:"bytes,3,opt,name=time,proto3" json:"time" yaml:"time"`
	Values               *DiskOnDemandInfo `protobuf:"bytes,4,opt,name=values,proto3" json:"values" yaml:"values"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *DiskOnDemandInfoResponse) Reset()         { *m = DiskOnDemandInfoResponse{} }
func (m *DiskOnDemandInfoResponse) String() string { return proto.CompactTextString(m) }
func (*DiskOnDemandInfoResponse) ProtoMessage()    {}
func (*DiskOnDemandInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{12}
}
func (m *DiskOnDemandInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiskOnDemandInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiskOnDemandInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiskOnDemandInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiskOnDemandInfoResponse.Merge(m, src)
}
func (m *DiskOnDemandInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *DiskOnDemandInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DiskOnDemandInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DiskOnDemandInfoResponse proto.InternalMessageInfo

func (m *DiskOnDemandInfoResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DiskOnDemandInfoResponse) GetTags() *Tags {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *DiskOnDemandInfoResponse) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

func (m *DiskOnDemandInfoResponse) GetValues() *DiskOnDemandInfo {
	if m != nil {
		return m.Values
	}
	return nil
}

type DiskOnDemandInfo struct {
	DiskFree             float64  `protobuf:"fixed64,1,opt,name=disk_free,proto3" json:"disk_free" yaml:"disk_free"`
	DiskTotal            float64  `protobuf:"fixed64,2,opt,name=disk_total,proto3" json:"disk_total" yaml:"disk_total"`
	DiskUsed             float64  `protobuf:"fixed64,3,opt,name=disk_used,proto3" json:"disk_used" yaml:"disk_used"`
	DiskUtilization      float64  `protobuf:"fixed64,4,opt,name=disk_utilization,proto3" json:"disk_utilization" yaml:"disk_utilization"`
	KbRead               float64  `protobuf:"fixed64,5,opt,name=kb_read,proto3" json:"kb_read" yaml:"kb_read"`
	KbWritten            float64  `protobuf:"fixed64,6,opt,name=kb_written,proto3" json:"kb_written" yaml:"kb_written"`
	OpsRead              float64  `protobuf:"fixed64,7,opt,name=ops_read,proto3" json:"ops_read" yaml:"ops_read"`
	OpsWrite             float64  `protobuf:"fixed64,8,opt,name=ops_write,proto3" json:"ops_write" yaml:"ops_write"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DiskOnDemandInfo) Reset()         { *m = DiskOnDemandInfo{} }
func (m *DiskOnDemandInfo) String() string { return proto.CompactTextString(m) }
func (*DiskOnDemandInfo) ProtoMessage()    {}
func (*DiskOnDemandInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{13}
}
func (m *DiskOnDemandInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiskOnDemandInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiskOnDemandInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiskOnDemandInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiskOnDemandInfo.Merge(m, src)
}
func (m *DiskOnDemandInfo) XXX_Size() int {
	return m.Size()
}
func (m *DiskOnDemandInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DiskOnDemandInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DiskOnDemandInfo proto.InternalMessageInfo

func (m *DiskOnDemandInfo) GetDiskFree() float64 {
	if m != nil {
		return m.DiskFree
	}
	return 0
}

func (m *DiskOnDemandInfo) GetDiskTotal() float64 {
	if m != nil {
		return m.DiskTotal
	}
	return 0
}

func (m *DiskOnDemandInfo) GetDiskUsed() float64 {
	if m != nil {
		return m.DiskUsed
	}
	return 0
}

func (m *DiskOnDemandInfo) GetDiskUtilization() float64 {
	if m != nil {
		return m.DiskUtilization
	}
	return 0
}

func (m *DiskOnDemandInfo) GetKbRead() float64 {
	if m != nil {
		return m.KbRead
	}
	return 0
}

func (m *DiskOnDemandInfo) GetKbWritten() float64 {
	if m != nil {
		return m.KbWritten
	}
	return 0
}

func (m *DiskOnDemandInfo) GetOpsRead() float64 {
	if m != nil {
		return m.OpsRead
	}
	return 0
}

func (m *DiskOnDemandInfo) GetOpsWrite() float64 {
	if m != nil {
		return m.OpsWrite
	}
	return 0
}

type NetworkOnDemandInfoResponse struct {
	Name                 string               `protobuf:"bytes,1,opt,name=name,proto3" json:"name" yaml:"name"`
	Tags                 *Tags                `protobuf:"bytes,2,opt,name=tags,proto3" json:"tags" yaml:"tags"`
	Time                 string               `protobuf:"bytes,3,opt,name=time,proto3" json:"time" yaml:"time"`
	Values               *NetworkOnDemandInfo `protobuf:"bytes,4,opt,name=values,proto3" json:"values" yaml:"values"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *NetworkOnDemandInfoResponse) Reset()         { *m = NetworkOnDemandInfoResponse{} }
func (m *NetworkOnDemandInfoResponse) String() string { return proto.CompactTextString(m) }
func (*NetworkOnDemandInfoResponse) ProtoMessage()    {}
func (*NetworkOnDemandInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{14}
}
func (m *NetworkOnDemandInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkOnDemandInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkOnDemandInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkOnDemandInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkOnDemandInfoResponse.Merge(m, src)
}
func (m *NetworkOnDemandInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *NetworkOnDemandInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkOnDemandInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkOnDemandInfoResponse proto.InternalMessageInfo

func (m *NetworkOnDemandInfoResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NetworkOnDemandInfoResponse) GetTags() *Tags {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *NetworkOnDemandInfoResponse) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

func (m *NetworkOnDemandInfoResponse) GetValues() *NetworkOnDemandInfo {
	if m != nil {
		return m.Values
	}
	return nil
}

type NetworkOnDemandInfo struct {
	BytesIn              float64  `protobuf:"fixed64,1,opt,name=bytes_in,proto3" json:"bytes_in" yaml:"bytes_in"`
	BytesOut             float64  `protobuf:"fixed64,2,opt,name=bytes_out,proto3" json:"bytes_out" yaml:"bytes_out"`
	PktsIn               float64  `protobuf:"fixed64,3,opt,name=pkts_in,proto3" json:"pkts_in" yaml:"pkts_in"`
	PktsOut              float64  `protobuf:"fixed64,4,opt,name=pkts_out,proto3" json:"pkts_out" yaml:"pkts_out"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkOnDemandInfo) Reset()         { *m = NetworkOnDemandInfo{} }
func (m *NetworkOnDemandInfo) String() string { return proto.CompactTextString(m) }
func (*NetworkOnDemandInfo) ProtoMessage()    {}
func (*NetworkOnDemandInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{15}
}
func (m *NetworkOnDemandInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkOnDemandInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkOnDemandInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkOnDemandInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkOnDemandInfo.Merge(m, src)
}
func (m *NetworkOnDemandInfo) XXX_Size() int {
	return m.Size()
}
func (m *NetworkOnDemandInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkOnDemandInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkOnDemandInfo proto.InternalMessageInfo

func (m *NetworkOnDemandInfo) GetBytesIn() float64 {
	if m != nil {
		return m.BytesIn
	}
	return 0
}

func (m *NetworkOnDemandInfo) GetBytesOut() float64 {
	if m != nil {
		return m.BytesOut
	}
	return 0
}

func (m *NetworkOnDemandInfo) GetPktsIn() float64 {
	if m != nil {
		return m.PktsIn
	}
	return 0
}

func (m *NetworkOnDemandInfo) GetPktsOut() float64 {
	if m != nil {
		return m.PktsOut
	}
	return 0
}

//////////////////////////////////
// MCIS 모니터링 메시지 정의
//////////////////////////////////
type MCISMonInfoResponse struct {
	Result               string   `protobuf:"bytes,1,opt,name=result,proto3" json:"result" yaml:"result"`
	Unit                 string   `protobuf:"bytes,2,opt,name=unit,proto3" json:"unit" yaml:"unit"`
	Desc                 string   `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc" yaml:"desc"`
	Elapsed              string   `protobuf:"bytes,4,opt,name=elapsed,proto3" json:"elapsed" yaml:"elapsed"`
	SpecId               string   `protobuf:"bytes,5,opt,name=spec_id,json=specid,proto3" json:"specid" yaml:"specid"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MCISMonInfoResponse) Reset()         { *m = MCISMonInfoResponse{} }
func (m *MCISMonInfoResponse) String() string { return proto.CompactTextString(m) }
func (*MCISMonInfoResponse) ProtoMessage()    {}
func (*MCISMonInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{16}
}
func (m *MCISMonInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MCISMonInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MCISMonInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MCISMonInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MCISMonInfoResponse.Merge(m, src)
}
func (m *MCISMonInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *MCISMonInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MCISMonInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MCISMonInfoResponse proto.InternalMessageInfo

func (m *MCISMonInfoResponse) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

func (m *MCISMonInfoResponse) GetUnit() string {
	if m != nil {
		return m.Unit
	}
	return ""
}

func (m *MCISMonInfoResponse) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *MCISMonInfoResponse) GetElapsed() string {
	if m != nil {
		return m.Elapsed
	}
	return ""
}

func (m *MCISMonInfoResponse) GetSpecId() string {
	if m != nil {
		return m.SpecId
	}
	return ""
}

type CpuInfoResponse struct {
	Name                 string     `protobuf:"bytes,1,opt,name=name,proto3" json:"name" yaml:"name"`
	Tags                 *Tags      `protobuf:"bytes,2,opt,name=tags,proto3" json:"tags" yaml:"tags"`
	Values               []*CpuInfo `protobuf:"bytes,3,rep,name=values,proto3" json:"values" yaml:"values"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *CpuInfoResponse) Reset()         { *m = CpuInfoResponse{} }
func (m *CpuInfoResponse) String() string { return proto.CompactTextString(m) }
func (*CpuInfoResponse) ProtoMessage()    {}
func (*CpuInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{17}
}
func (m *CpuInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CpuInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CpuInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CpuInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CpuInfoResponse.Merge(m, src)
}
func (m *CpuInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *CpuInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CpuInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CpuInfoResponse proto.InternalMessageInfo

func (m *CpuInfoResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CpuInfoResponse) GetTags() *Tags {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *CpuInfoResponse) GetValues() []*CpuInfo {
	if m != nil {
		return m.Values
	}
	return nil
}

type CpuInfo struct {
	CpuUtilization       float64  `protobuf:"fixed64,1,opt,name=cpu_utilization,proto3" json:"cpu_utilization" yaml:"cpu_utilization"`
	CpuSystem            float64  `protobuf:"fixed64,2,opt,name=cpu_system,proto3" json:"cpu_system" yaml:"cpu_system"`
	CpuIdle              float64  `protobuf:"fixed64,3,opt,name=cpu_idle,proto3" json:"cpu_idle" yaml:"cpu_idle"`
	CpuIowait            float64  `protobuf:"fixed64,4,opt,name=cpu_iowait,proto3" json:"cpu_iowait" yaml:"cpu_iowait"`
	CpuHintr             float64  `protobuf:"fixed64,5,opt,name=cpu_hintr,proto3" json:"cpu_hintr" yaml:"cpu_hintr"`
	CpuSintr             float64  `protobuf:"fixed64,6,opt,name=cpu_sintr,proto3" json:"cpu_sintr" yaml:"cpu_sintr"`
	CpuUser              float64  `protobuf:"fixed64,7,opt,name=cpu_user,proto3" json:"cpu_user" yaml:"cpu_user"`
	CpuNice              float64  `protobuf:"fixed64,8,opt,name=cpu_nice,proto3" json:"cpu_nice" yaml:"cpu_nice"`
	CpuSteal             float64  `protobuf:"fixed64,9,opt,name=cpu_steal,proto3" json:"cpu_steal" yaml:"cpu_steal"`
	CpuGuest             float64  `protobuf:"fixed64,10,opt,name=cpu_guest,proto3" json:"cpu_guest" yaml:"cpu_guest"`
	CpuGuestNice         float64  `protobuf:"fixed64,11,opt,name=cpu_guest_nice,proto3" json:"cpu_guest_nice" yaml:"cpu_guest_nice"`
	Time                 string   `protobuf:"bytes,12,opt,name=time,proto3" json:"time" yaml:"time"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CpuInfo) Reset()         { *m = CpuInfo{} }
func (m *CpuInfo) String() string { return proto.CompactTextString(m) }
func (*CpuInfo) ProtoMessage()    {}
func (*CpuInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{18}
}
func (m *CpuInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CpuInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CpuInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CpuInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CpuInfo.Merge(m, src)
}
func (m *CpuInfo) XXX_Size() int {
	return m.Size()
}
func (m *CpuInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CpuInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CpuInfo proto.InternalMessageInfo

func (m *CpuInfo) GetCpuUtilization() float64 {
	if m != nil {
		return m.CpuUtilization
	}
	return 0
}

func (m *CpuInfo) GetCpuSystem() float64 {
	if m != nil {
		return m.CpuSystem
	}
	return 0
}

func (m *CpuInfo) GetCpuIdle() float64 {
	if m != nil {
		return m.CpuIdle
	}
	return 0
}

func (m *CpuInfo) GetCpuIowait() float64 {
	if m != nil {
		return m.CpuIowait
	}
	return 0
}

func (m *CpuInfo) GetCpuHintr() float64 {
	if m != nil {
		return m.CpuHintr
	}
	return 0
}

func (m *CpuInfo) GetCpuSintr() float64 {
	if m != nil {
		return m.CpuSintr
	}
	return 0
}

func (m *CpuInfo) GetCpuUser() float64 {
	if m != nil {
		return m.CpuUser
	}
	return 0
}

func (m *CpuInfo) GetCpuNice() float64 {
	if m != nil {
		return m.CpuNice
	}
	return 0
}

func (m *CpuInfo) GetCpuSteal() float64 {
	if m != nil {
		return m.CpuSteal
	}
	return 0
}

func (m *CpuInfo) GetCpuGuest() float64 {
	if m != nil {
		return m.CpuGuest
	}
	return 0
}

func (m *CpuInfo) GetCpuGuestNice() float64 {
	if m != nil {
		return m.CpuGuestNice
	}
	return 0
}

func (m *CpuInfo) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

type CpuFreqInfoResponse struct {
	Name                 string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name" yaml:"name"`
	Tags                 *Tags          `protobuf:"bytes,2,opt,name=tags,proto3" json:"tags" yaml:"tags"`
	Values               []*CpuFreqInfo `protobuf:"bytes,3,rep,name=values,proto3" json:"values" yaml:"values"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CpuFreqInfoResponse) Reset()         { *m = CpuFreqInfoResponse{} }
func (m *CpuFreqInfoResponse) String() string { return proto.CompactTextString(m) }
func (*CpuFreqInfoResponse) ProtoMessage()    {}
func (*CpuFreqInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{19}
}
func (m *CpuFreqInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CpuFreqInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CpuFreqInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CpuFreqInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CpuFreqInfoResponse.Merge(m, src)
}
func (m *CpuFreqInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *CpuFreqInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CpuFreqInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CpuFreqInfoResponse proto.InternalMessageInfo

func (m *CpuFreqInfoResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CpuFreqInfoResponse) GetTags() *Tags {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *CpuFreqInfoResponse) GetValues() []*CpuFreqInfo {
	if m != nil {
		return m.Values
	}
	return nil
}

type CpuFreqInfo struct {
	CpuSpeed             float64  `protobuf:"fixed64,1,opt,name=cpu_speed,proto3" json:"cpu_speed" yaml:"cpu_speed"`
	Time                 string   `protobuf:"bytes,2,opt,name=time,proto3" json:"time" yaml:"time"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CpuFreqInfo) Reset()         { *m = CpuFreqInfo{} }
func (m *CpuFreqInfo) String() string { return proto.CompactTextString(m) }
func (*CpuFreqInfo) ProtoMessage()    {}
func (*CpuFreqInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{20}
}
func (m *CpuFreqInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CpuFreqInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CpuFreqInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CpuFreqInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CpuFreqInfo.Merge(m, src)
}
func (m *CpuFreqInfo) XXX_Size() int {
	return m.Size()
}
func (m *CpuFreqInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CpuFreqInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CpuFreqInfo proto.InternalMessageInfo

func (m *CpuFreqInfo) GetCpuSpeed() float64 {
	if m != nil {
		return m.CpuSpeed
	}
	return 0
}

func (m *CpuFreqInfo) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

type MemoryInfoResponse struct {
	Name                 string        `protobuf:"bytes,1,opt,name=name,proto3" json:"name" yaml:"name"`
	Tags                 *Tags         `protobuf:"bytes,2,opt,name=tags,proto3" json:"tags" yaml:"tags"`
	Values               []*MemoryInfo `protobuf:"bytes,3,rep,name=values,proto3" json:"values" yaml:"values"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *MemoryInfoResponse) Reset()         { *m = MemoryInfoResponse{} }
func (m *MemoryInfoResponse) String() string { return proto.CompactTextString(m) }
func (*MemoryInfoResponse) ProtoMessage()    {}
func (*MemoryInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{21}
}
func (m *MemoryInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoryInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoryInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoryInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoryInfoResponse.Merge(m, src)
}
func (m *MemoryInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *MemoryInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoryInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MemoryInfoResponse proto.InternalMessageInfo

func (m *MemoryInfoResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MemoryInfoResponse) GetTags() *Tags {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *MemoryInfoResponse) GetValues() []*MemoryInfo {
	if m != nil {
		return m.Values
	}
	return nil
}

type MemoryInfo struct {
	MemUtilization       float64  `protobuf:"fixed64,1,opt,name=mem_utilization,proto3" json:"mem_utilization" yaml:"mem_utilization"`
	MemTotal             float64  `protobuf:"fixed64,2,opt,name=mem_total,proto3" json:"mem_total" yaml:"mem_total"`
	MemUsed              float64  `protobuf:"fixed64,3,opt,name=mem_used,proto3" json:"mem_used" yaml:"mem_used"`
	MemFree              float64  `protobuf:"fixed64,4,opt,name=mem_free,proto3" json:"mem_free" yaml:"mem_free"`
	MemShared            float64  `protobuf:"fixed64,5,opt,name=mem_shared,proto3" json:"mem_shared" yaml:"mem_shared"`
	MemBuffers           float64  `protobuf:"fixed64,6,opt,name=mem_buffers,proto3" json:"mem_buffers" yaml:"mem_buffers"`
	MemCached            float64  `protobuf:"fixed64,7,opt,name=mem_cached,proto3" json:"mem_cached" yaml:"mem_cached"`
	Time                 string   `protobuf:"bytes,8,opt,name=time,proto3" json:"time" yaml:"time"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MemoryInfo) Reset()         { *m = MemoryInfo{} }
func (m *MemoryInfo) String() string { return proto.CompactTextString(m) }
func (*MemoryInfo) ProtoMessage()    {}
func (*MemoryInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{22}
}
func (m *MemoryInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoryInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoryInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoryInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoryInfo.Merge(m, src)
}
func (m *MemoryInfo) XXX_Size() int {
	return m.Size()
}
func (m *MemoryInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoryInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MemoryInfo proto.InternalMessageInfo

func (m *MemoryInfo) GetMemUtilization() float64 {
	if m != nil {
		return m.MemUtilization
	}
	return 0
}

func (m *MemoryInfo) GetMemTotal() float64 {
	if m != nil {
		return m.MemTotal
	}
	return 0
}

func (m *MemoryInfo) GetMemUsed() float64 {
	if m != nil {
		return m.MemUsed
	}
	return 0
}

func (m *MemoryInfo) GetMemFree() float64 {
	if m != nil {
		return m.MemFree
	}
	return 0
}

func (m *MemoryInfo) GetMemShared() float64 {
	if m != nil {
		return m.MemShared
	}
	return 0
}

func (m *MemoryInfo) GetMemBuffers() float64 {
	if m != nil {
		return m.MemBuffers
	}
	return 0
}

func (m *MemoryInfo) GetMemCached() float64 {
	if m != nil {
		return m.MemCached
	}
	return 0
}

func (m *MemoryInfo) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

type DiskInfoResponse struct {
	Name                 string      `protobuf:"bytes,1,opt,name=name,proto3" json:"name" yaml:"name"`
	Tags                 *Tags       `protobuf:"bytes,2,opt,name=tags,proto3" json:"tags" yaml:"tags"`
	Values               []*DiskInfo `protobuf:"bytes,3,rep,name=values,proto3" json:"values" yaml:"values"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *DiskInfoResponse) Reset()         { *m = DiskInfoResponse{} }
func (m *DiskInfoResponse) String() string { return proto.CompactTextString(m) }
func (*DiskInfoResponse) ProtoMessage()    {}
func (*DiskInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{23}
}
func (m *DiskInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiskInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiskInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiskInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiskInfoResponse.Merge(m, src)
}
func (m *DiskInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *DiskInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DiskInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DiskInfoResponse proto.InternalMessageInfo

func (m *DiskInfoResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DiskInfoResponse) GetTags() *Tags {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *DiskInfoResponse) GetValues() []*DiskInfo {
	if m != nil {
		return m.Values
	}
	return nil
}

type DiskInfo struct {
	Free                 float64  `protobuf:"fixed64,1,opt,name=free,proto3" json:"free" yaml:"free"`
	ReadBytes            float64  `protobuf:"fixed64,2,opt,name=read_bytes,proto3" json:"read_bytes" yaml:"read_bytes"`
	ReadTime             float64  `protobuf:"fixed64,3,opt,name=read_time,proto3" json:"read_time" yaml:"read_time"`
	Reads                float64  `protobuf:"fixed64,4,opt,name=reads,proto3" json:"reads" yaml:"reads"`
	Total                float64  `protobuf:"fixed64,5,opt,name=total,proto3" json:"total" yaml:"total"`
	Used                 float64  `protobuf:"fixed64,6,opt,name=used,proto3" json:"used" yaml:"used"`
	UsedPercent          float64  `protobuf:"fixed64,7,opt,name=used_percent,proto3" json:"used_percent" yaml:"used_percent"`
	WriteBytes           float64  `protobuf:"fixed64,8,opt,name=write_bytes,proto3" json:"write_bytes" yaml:"write_bytes"`
	WriteTime            float64  `protobuf:"fixed64,9,opt,name=write_time,proto3" json:"write_time" yaml:"write_time"`
	Writes               float64  `protobuf:"fixed64,10,opt,name=writes,proto3" json:"writes" yaml:"writes"`
	Time                 string   `protobuf:"bytes,11,opt,name=time,proto3" json:"time" yaml:"time"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DiskInfo) Reset()         { *m = DiskInfo{} }
func (m *DiskInfo) String() string { return proto.CompactTextString(m) }
func (*DiskInfo) ProtoMessage()    {}
func (*DiskInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{24}
}
func (m *DiskInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiskInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiskInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiskInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiskInfo.Merge(m, src)
}
func (m *DiskInfo) XXX_Size() int {
	return m.Size()
}
func (m *DiskInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DiskInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DiskInfo proto.InternalMessageInfo

func (m *DiskInfo) GetFree() float64 {
	if m != nil {
		return m.Free
	}
	return 0
}

func (m *DiskInfo) GetReadBytes() float64 {
	if m != nil {
		return m.ReadBytes
	}
	return 0
}

func (m *DiskInfo) GetReadTime() float64 {
	if m != nil {
		return m.ReadTime
	}
	return 0
}

func (m *DiskInfo) GetReads() float64 {
	if m != nil {
		return m.Reads
	}
	return 0
}

func (m *DiskInfo) GetTotal() float64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *DiskInfo) GetUsed() float64 {
	if m != nil {
		return m.Used
	}
	return 0
}

func (m *DiskInfo) GetUsedPercent() float64 {
	if m != nil {
		return m.UsedPercent
	}
	return 0
}

func (m *DiskInfo) GetWriteBytes() float64 {
	if m != nil {
		return m.WriteBytes
	}
	return 0
}

func (m *DiskInfo) GetWriteTime() float64 {
	if m != nil {
		return m.WriteTime
	}
	return 0
}

func (m *DiskInfo) GetWrites() float64 {
	if m != nil {
		return m.Writes
	}
	return 0
}

func (m *DiskInfo) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

type NetworkInfoResponse struct {
	Name                 string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name" yaml:"name"`
	Tags                 *Tags          `protobuf:"bytes,2,opt,name=tags,proto3" json:"tags" yaml:"tags"`
	Values               []*NetworkInfo `protobuf:"bytes,3,rep,name=values,proto3" json:"values" yaml:"values"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *NetworkInfoResponse) Reset()         { *m = NetworkInfoResponse{} }
func (m *NetworkInfoResponse) String() string { return proto.CompactTextString(m) }
func (*NetworkInfoResponse) ProtoMessage()    {}
func (*NetworkInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{25}
}
func (m *NetworkInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkInfoResponse.Merge(m, src)
}
func (m *NetworkInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *NetworkInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkInfoResponse proto.InternalMessageInfo

func (m *NetworkInfoResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NetworkInfoResponse) GetTags() *Tags {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *NetworkInfoResponse) GetValues() []*NetworkInfo {
	if m != nil {
		return m.Values
	}
	return nil
}

type NetworkInfo struct {
	BytesIn              float64  `protobuf:"fixed64,1,opt,name=bytes_in,proto3" json:"bytes_in" yaml:"bytes_in"`
	BytesOut             float64  `protobuf:"fixed64,2,opt,name=bytes_out,proto3" json:"bytes_out" yaml:"bytes_out"`
	PktsIn               float64  `protobuf:"fixed64,3,opt,name=pkts_in,proto3" json:"pkts_in" yaml:"pkts_in"`
	PktsOut              float64  `protobuf:"fixed64,4,opt,name=pkts_out,proto3" json:"pkts_out" yaml:"pkts_out"`
	Time                 string   `protobuf:"bytes,5,opt,name=time,proto3" json:"time" yaml:"time"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkInfo) Reset()         { *m = NetworkInfo{} }
func (m *NetworkInfo) String() string { return proto.CompactTextString(m) }
func (*NetworkInfo) ProtoMessage()    {}
func (*NetworkInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{26}
}
func (m *NetworkInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkInfo.Merge(m, src)
}
func (m *NetworkInfo) XXX_Size() int {
	return m.Size()
}
func (m *NetworkInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkInfo proto.InternalMessageInfo

func (m *NetworkInfo) GetBytesIn() float64 {
	if m != nil {
		return m.BytesIn
	}
	return 0
}

func (m *NetworkInfo) GetBytesOut() float64 {
	if m != nil {
		return m.BytesOut
	}
	return 0
}

func (m *NetworkInfo) GetPktsIn() float64 {
	if m != nil {
		return m.PktsIn
	}
	return 0
}

func (m *NetworkInfo) GetPktsOut() float64 {
	if m != nil {
		return m.PktsOut
	}
	return 0
}

func (m *NetworkInfo) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

type MonitoringConfigRequest struct {
	Item                 *MonitoringConfigInfo `protobuf:"bytes,1,opt,name=item,json=common,proto3" json:"common" yaml:"common"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *MonitoringConfigRequest) Reset()         { *m = MonitoringConfigRequest{} }
func (m *MonitoringConfigRequest) String() string { return proto.CompactTextString(m) }
func (*MonitoringConfigRequest) ProtoMessage()    {}
func (*MonitoringConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{27}
}
func (m *MonitoringConfigRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MonitoringConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MonitoringConfigRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MonitoringConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MonitoringConfigRequest.Merge(m, src)
}
func (m *MonitoringConfigRequest) XXX_Size() int {
	return m.Size()
}
func (m *MonitoringConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MonitoringConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MonitoringConfigRequest proto.InternalMessageInfo

func (m *MonitoringConfigRequest) GetItem() *MonitoringConfigInfo {
	if m != nil {
		return m.Item
	}
	return nil
}

type MonitoringConfigResponse struct {
	Item                 *MonitoringConfigInfo `protobuf:"bytes,1,opt,name=item,json=common,proto3" json:"common" yaml:"common"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *MonitoringConfigResponse) Reset()         { *m = MonitoringConfigResponse{} }
func (m *MonitoringConfigResponse) String() string { return proto.CompactTextString(m) }
func (*MonitoringConfigResponse) ProtoMessage()    {}
func (*MonitoringConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{28}
}
func (m *MonitoringConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MonitoringConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MonitoringConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MonitoringConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MonitoringConfigResponse.Merge(m, src)
}
func (m *MonitoringConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *MonitoringConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MonitoringConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MonitoringConfigResponse proto.InternalMessageInfo

func (m *MonitoringConfigResponse) GetItem() *MonitoringConfigInfo {
	if m != nil {
		return m.Item
	}
	return nil
}

type MonitoringConfigInfo struct {
	AgentInterval        int32    `protobuf:"varint,1,opt,name=agent_interval,proto3" json:"agent_interval" yaml:"agent_interval"`
	CollectorInterval    int32    `protobuf:"varint,2,opt,name=collector_interval,proto3" json:"collector_interval" yaml:"collector_interval"`
	MaxHostCount         int32    `protobuf:"varint,4,opt,name=max_host_count,proto3" json:"max_host_count" yaml:"max_host_count"`
	MonitoringPolicy     string   `protobuf:"bytes,5,opt,name=monitoring_policy,proto3" json:"monitoring_policy" yaml:"monitoring_policy"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MonitoringConfigInfo) Reset()         { *m = MonitoringConfigInfo{} }
func (m *MonitoringConfigInfo) String() string { return proto.CompactTextString(m) }
func (*MonitoringConfigInfo) ProtoMessage()    {}
func (*MonitoringConfigInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{29}
}
func (m *MonitoringConfigInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MonitoringConfigInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MonitoringConfigInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MonitoringConfigInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MonitoringConfigInfo.Merge(m, src)
}
func (m *MonitoringConfigInfo) XXX_Size() int {
	return m.Size()
}
func (m *MonitoringConfigInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MonitoringConfigInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MonitoringConfigInfo proto.InternalMessageInfo

func (m *MonitoringConfigInfo) GetAgentInterval() int32 {
	if m != nil {
		return m.AgentInterval
	}
	return 0
}

func (m *MonitoringConfigInfo) GetCollectorInterval() int32 {
	if m != nil {
		return m.CollectorInterval
	}
	return 0
}

func (m *MonitoringConfigInfo) GetMaxHostCount() int32 {
	if m != nil {
		return m.MaxHostCount
	}
	return 0
}

func (m *MonitoringConfigInfo) GetMonitoringPolicy() string {
	if m != nil {
		return m.MonitoringPolicy
	}
	return ""
}

type InstallAgentRequest struct {
	NsId                 string   `protobuf:"bytes,1,opt,name=ns_id,proto3" json:"ns_id" yaml:"ns_id"`
	McisId               string   `protobuf:"bytes,2,opt,name=mcis_id,proto3" json:"mcis_id" yaml:"mcis_id"`
	VmId                 string   `protobuf:"bytes,3,opt,name=vm_id,proto3" json:"vm_id" yaml:"vm_id"`
	PublicIp             string   `protobuf:"bytes,4,opt,name=public_ip,proto3" json:"public_ip" yaml:"public_ip"`
	UserName             string   `protobuf:"bytes,5,opt,name=user_name,proto3" json:"user_name" yaml:"user_name"`
	SshKey               string   `protobuf:"bytes,6,opt,name=ssh_key,proto3" json:"ssh_key" yaml:"ssh_key"`
	CspType              string   `protobuf:"bytes,7,opt,name=csp_type,proto3" json:"csp_type" yaml:"csp_type"`
	Port                 string   `protobuf:"bytes,8,opt,name=port,proto3" json:"port" yaml:"port"`
	ServiceType                 string   `protobuf:"bytes,8,opt,name=port,proto3" json:"service_type" yaml:"service_type"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InstallAgentRequest) Reset()         { *m = InstallAgentRequest{} }
func (m *InstallAgentRequest) String() string { return proto.CompactTextString(m) }
func (*InstallAgentRequest) ProtoMessage()    {}
func (*InstallAgentRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{30}
}
func (m *InstallAgentRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstallAgentRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstallAgentRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstallAgentRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallAgentRequest.Merge(m, src)
}
func (m *InstallAgentRequest) XXX_Size() int {
	return m.Size()
}
func (m *InstallAgentRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallAgentRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InstallAgentRequest proto.InternalMessageInfo

func (m *InstallAgentRequest) GetNsId() string {
	if m != nil {
		return m.NsId
	}
	return ""
}

func (m *InstallAgentRequest) GetMcisId() string {
	if m != nil {
		return m.McisId
	}
	return ""
}

func (m *InstallAgentRequest) GetVmId() string {
	if m != nil {
		return m.VmId
	}
	return ""
}

func (m *InstallAgentRequest) GetPublicIp() string {
	if m != nil {
		return m.PublicIp
	}
	return ""
}

func (m *InstallAgentRequest) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *InstallAgentRequest) GetSshKey() string {
	if m != nil {
		return m.SshKey
	}
	return ""
}

func (m *InstallAgentRequest) GetCspType() string {
	if m != nil {
		return m.CspType
	}
	return ""
}

func (m *InstallAgentRequest) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

func init() {
	proto.RegisterType((*Empty)(nil), "cbdragonfly.Empty")
	proto.RegisterType((*MessageResponse)(nil), "cbdragonfly.MessageResponse")
	proto.RegisterType((*Tags)(nil), "cbdragonfly.Tags")
	proto.RegisterType((*VMMonQryRequest)(nil), "cbdragonfly.VMMonQryRequest")
	proto.RegisterType((*VMOnDemandMonQryRequest)(nil), "cbdragonfly.VMOnDemandMonQryRequest")
	proto.RegisterType((*VMMCISMonQryRequest)(nil), "cbdragonfly.VMMCISMonQryRequest")
	proto.RegisterType((*CpuOnDemandInfoResponse)(nil), "cbdragonfly.CpuOnDemandInfoResponse")
	proto.RegisterType((*CpuOnDemandInfo)(nil), "cbdragonfly.CpuOnDemandInfo")
	proto.RegisterType((*CpuFreqOnDemandInfoResponse)(nil), "cbdragonfly.CpuFreqOnDemandInfoResponse")
	proto.RegisterType((*CpuFreqOnDemandInfo)(nil), "cbdragonfly.CpuFreqOnDemandInfo")
	proto.RegisterType((*MemoryOnDemandInfoResponse)(nil), "cbdragonfly.MemoryOnDemandInfoResponse")
	proto.RegisterType((*MemoryOnDemandInfo)(nil), "cbdragonfly.MemoryOnDemandInfo")
	proto.RegisterType((*DiskOnDemandInfoResponse)(nil), "cbdragonfly.DiskOnDemandInfoResponse")
	proto.RegisterType((*DiskOnDemandInfo)(nil), "cbdragonfly.DiskOnDemandInfo")
	proto.RegisterType((*NetworkOnDemandInfoResponse)(nil), "cbdragonfly.NetworkOnDemandInfoResponse")
	proto.RegisterType((*NetworkOnDemandInfo)(nil), "cbdragonfly.NetworkOnDemandInfo")
	proto.RegisterType((*MCISMonInfoResponse)(nil), "cbdragonfly.MCISMonInfoResponse")
	proto.RegisterType((*CpuInfoResponse)(nil), "cbdragonfly.CpuInfoResponse")
	proto.RegisterType((*CpuInfo)(nil), "cbdragonfly.CpuInfo")
	proto.RegisterType((*CpuFreqInfoResponse)(nil), "cbdragonfly.CpuFreqInfoResponse")
	proto.RegisterType((*CpuFreqInfo)(nil), "cbdragonfly.CpuFreqInfo")
	proto.RegisterType((*MemoryInfoResponse)(nil), "cbdragonfly.MemoryInfoResponse")
	proto.RegisterType((*MemoryInfo)(nil), "cbdragonfly.MemoryInfo")
	proto.RegisterType((*DiskInfoResponse)(nil), "cbdragonfly.DiskInfoResponse")
	proto.RegisterType((*DiskInfo)(nil), "cbdragonfly.DiskInfo")
	proto.RegisterType((*NetworkInfoResponse)(nil), "cbdragonfly.NetworkInfoResponse")
	proto.RegisterType((*NetworkInfo)(nil), "cbdragonfly.NetworkInfo")
	proto.RegisterType((*MonitoringConfigRequest)(nil), "cbdragonfly.MonitoringConfigRequest")
	proto.RegisterType((*MonitoringConfigResponse)(nil), "cbdragonfly.MonitoringConfigResponse")
	proto.RegisterType((*MonitoringConfigInfo)(nil), "cbdragonfly.MonitoringConfigInfo")
	proto.RegisterType((*InstallAgentRequest)(nil), "cbdragonfly.InstallAgentRequest")
}

func init() { proto.RegisterFile("cbdragonfly/cbdragonfly.proto", fileDescriptor_3ada617ac924eafc) }

var fileDescriptor_3ada617ac924eafc = []byte{
	// 2327 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0xcd, 0x8f, 0x1c, 0x47,
	0x15, 0xdf, 0x99, 0x9d, 0xfd, 0x70, 0x8d, 0xf1, 0xda, 0xbd, 0x0e, 0x3b, 0xf1, 0x57, 0x3b, 0x45,
	0xa2, 0x58, 0x0a, 0xc4, 0xc2, 0x8e, 0x84, 0x44, 0x24, 0x22, 0xbc, 0x06, 0xcb, 0x81, 0x89, 0x71,
	0xd9, 0x71, 0x0e, 0x08, 0x8d, 0x7a, 0x67, 0x6a, 0x67, 0x5b, 0x3b, 0xfd, 0x91, 0xee, 0x1e, 0x9b,
	0x81, 0x2b, 0x8a, 0x40, 0x42, 0x5c, 0x10, 0x52, 0x8e, 0x5c, 0xb9, 0x70, 0xe0, 0xc0, 0xdf, 0x00,
	0xe2, 0x00, 0x1c, 0xb8, 0xb6, 0x90, 0xb9, 0xcd, 0x8d, 0xb9, 0xc2, 0x01, 0xbd, 0x57, 0x1f, 0xaf,
	0xba, 0x67, 0x76, 0x33, 0xe1, 0x43, 0x66, 0x63, 0x9f, 0xa6, 0xde, 0xef, 0xd5, 0x7b, 0x55, 0xf5,
	0xde, 0xab, 0x57, 0xf5, 0x7a, 0x8a, 0x5d, 0xee, 0xef, 0x0d, 0xb2, 0x60, 0x98, 0xc4, 0xfb, 0xa3,
	0xc9, 0x75, 0xa7, 0xfd, 0x66, 0x9a, 0x25, 0x45, 0xe2, 0xb5, 0x1d, 0xe8, 0xc2, 0xf9, 0x61, 0x32,
	0x4c, 0x10, 0xbf, 0x0e, 0x2d, 0xd5, 0x85, 0x6f, 0xb0, 0xb5, 0x6f, 0x44, 0x69, 0x31, 0xe1, 0xef,
	0xb2, 0xad, 0xae, 0xcc, 0xf3, 0x60, 0x28, 0x85, 0xcc, 0xd3, 0x24, 0xce, 0xa5, 0xf7, 0x15, 0xb6,
	0x11, 0x29, 0xa8, 0xd3, 0xb8, 0xda, 0xb8, 0x76, 0xea, 0xd6, 0xe5, 0x69, 0xe9, 0x1b, 0x68, 0x56,
	0xfa, 0x67, 0x26, 0x41, 0x34, 0xfa, 0x2a, 0xd7, 0x00, 0x17, 0x86, 0xc5, 0x3f, 0x6e, 0xb0, 0xd6,
	0xc3, 0x60, 0x98, 0x7b, 0x5f, 0x64, 0x6b, 0x71, 0xde, 0x0b, 0x07, 0x5a, 0x7e, 0x67, 0x5a, 0xfa,
	0xad, 0x38, 0xbf, 0x3b, 0x98, 0x95, 0x7e, 0x5b, 0x09, 0x03, 0xc5, 0x05, 0x82, 0xde, 0x5b, 0x6c,
	0x23, 0xea, 0x87, 0xd8, 0xbf, 0x89, 0xfd, 0x2f, 0x4e, 0x4b, 0x7f, 0x1d, 0x20, 0x94, 0xf8, 0x9c,
	0x1e, 0x0e, 0x69, 0x2e, 0x34, 0x03, 0xc6, 0x78, 0x1c, 0x81, 0xcc, 0x2a, 0x8d, 0xf1, 0x38, 0x72,
	0xc7, 0x00, 0x8a, 0x0b, 0x04, 0xf9, 0x2f, 0x56, 0xd9, 0xd6, 0xa3, 0x6e, 0x37, 0x89, 0xef, 0x67,
	0x13, 0x21, 0x3f, 0x1c, 0xcb, 0xbc, 0xf0, 0xae, 0x57, 0x67, 0xf9, 0xf2, 0xb4, 0xf4, 0x15, 0x30,
	0x2b, 0xfd, 0xd3, 0x66, 0x9a, 0xbd, 0x70, 0xc0, 0x85, 0x82, 0xd1, 0x30, 0x95, 0x89, 0x2a, 0xc3,
	0x28, 0xc8, 0x31, 0x8c, 0x02, 0xc0, 0x30, 0xaa, 0x05, 0x23, 0xb9, 0x73, 0xc5, 0x91, 0x10, 0xa0,
	0x91, 0x90, 0xe4, 0x42, 0xc1, 0xde, 0x6d, 0xd6, 0x4e, 0x65, 0x16, 0x26, 0x83, 0x5e, 0x31, 0x49,
	0x65, 0xa7, 0x85, 0x62, 0x5f, 0x98, 0x96, 0x3e, 0x53, 0xf0, 0xc3, 0x49, 0x0a, 0x9e, 0x38, 0xa7,
	0x64, 0x09, 0xe3, 0xc2, 0xe9, 0xe0, 0x0d, 0xd8, 0x76, 0x5e, 0x04, 0x45, 0x98, 0x17, 0x61, 0x3f,
	0xef, 0xf5, 0xb3, 0xb0, 0x90, 0x59, 0x18, 0x74, 0xd6, 0x50, 0xdb, 0xcd, 0x69, 0xe9, 0x7b, 0xc4,
	0xde, 0xd5, 0xdc, 0x59, 0xe9, 0xbf, 0xac, 0xb4, 0xce, 0xf3, 0xb8, 0x58, 0x20, 0xe0, 0xbd, 0xcd,
	0x36, 0x07, 0xe3, 0x2c, 0x28, 0xc2, 0x24, 0xee, 0xac, 0xa3, 0x6a, 0x7f, 0x5a, 0xfa, 0x16, 0x9b,
	0x95, 0xfe, 0x96, 0x52, 0x68, 0x10, 0x2e, 0x2c, 0x93, 0xff, 0xbd, 0xc1, 0x76, 0x1e, 0x75, 0xef,
	0xc5, 0xb7, 0x65, 0x14, 0xc4, 0x83, 0x13, 0xe3, 0x9f, 0xb7, 0xd9, 0x66, 0x30, 0x94, 0x71, 0xd1,
	0x0b, 0x53, 0xed, 0x1c, 0x5c, 0xb3, 0xc1, 0x68, 0xcd, 0x06, 0xe1, 0xc2, 0x32, 0xf9, 0x6f, 0x9b,
	0x6c, 0xfb, 0x51, 0xb7, 0xbb, 0x7b, 0xf7, 0xc1, 0x73, 0xb1, 0x5e, 0xef, 0x0e, 0x6b, 0x47, 0xb2,
	0xc8, 0xc2, 0x7e, 0x2f, 0x0e, 0x22, 0xa9, 0xc3, 0xef, 0xb5, 0x69, 0xe9, 0xbb, 0xf0, 0xac, 0xf4,
	0x3d, 0x93, 0x57, 0x2c, 0xc8, 0x85, 0xdb, 0x85, 0x7f, 0xd4, 0x64, 0x3b, 0xbb, 0xe9, 0xd8, 0x44,
	0xcb, 0xdd, 0x78, 0x3f, 0xb1, 0x49, 0xeb, 0x0d, 0xd6, 0x42, 0xed, 0x6e, 0xc6, 0x51, 0x6a, 0x4d,
	0xc6, 0x41, 0x7d, 0x08, 0x7a, 0x5f, 0x63, 0xad, 0x22, 0x18, 0xe6, 0x68, 0xb5, 0xf6, 0x8d, 0x73,
	0x6f, 0xba, 0x29, 0x14, 0x12, 0x98, 0x92, 0x87, 0x2e, 0x24, 0x0f, 0x14, 0x17, 0x08, 0xc2, 0x60,
	0x45, 0x18, 0x49, 0x37, 0xf5, 0x00, 0xed, 0x74, 0x0e, 0x71, 0x30, 0xf8, 0xf1, 0xee, 0xb3, 0xf5,
	0xc7, 0xc1, 0x68, 0x2c, 0x73, 0xb4, 0x5c, 0xfb, 0xc6, 0xa5, 0xca, 0x70, 0xb5, 0xf5, 0xa8, 0xdc,
	0xa7, 0xfa, 0x53, 0xee, 0x53, 0x34, 0x17, 0x9a, 0xc1, 0x7f, 0xb4, 0xce, 0xb6, 0x6a, 0x82, 0xde,
	0x07, 0x6c, 0xab, 0x9f, 0x8e, 0x7b, 0xe3, 0x22, 0x1c, 0x85, 0x3f, 0x50, 0xbb, 0x11, 0x6c, 0xd1,
	0xb8, 0xf5, 0xa5, 0x69, 0xe9, 0xd7, 0x59, 0xb3, 0xd2, 0xff, 0xbc, 0x52, 0x5d, 0x63, 0x70, 0x51,
	0xef, 0xea, 0xed, 0x32, 0x06, 0x50, 0x3e, 0xc9, 0x0b, 0x19, 0xa1, 0xc9, 0x1a, 0x2a, 0x15, 0x11,
	0x4a, 0xa9, 0x88, 0x30, 0x2e, 0x9c, 0x0e, 0x10, 0x40, 0x40, 0x85, 0x83, 0x91, 0xb2, 0x5a, 0x43,
	0x05, 0x90, 0xc1, 0x28, 0x80, 0x0c, 0xc2, 0x85, 0x65, 0x9a, 0x19, 0x84, 0xc9, 0x93, 0x20, 0x2c,
	0xd0, 0x8a, 0xce, 0x0c, 0x14, 0x5a, 0x9d, 0x81, 0xc2, 0xf4, 0x0c, 0x14, 0xe1, 0xbd, 0xc3, 0x4e,
	0x01, 0x75, 0x10, 0xc6, 0x45, 0x86, 0x31, 0xd8, 0xb8, 0xf5, 0xca, 0xb4, 0xf4, 0x09, 0x9c, 0x95,
	0xfe, 0x59, 0x52, 0x81, 0x10, 0x17, 0xc4, 0x36, 0x0a, 0x72, 0x54, 0xb0, 0x5e, 0x55, 0x90, 0xcf,
	0x2b, 0xc8, 0x1d, 0x05, 0xd8, 0x36, 0x36, 0x18, 0xe7, 0x32, 0xeb, 0x6c, 0x54, 0x6d, 0x00, 0x58,
	0xd5, 0x06, 0x80, 0x68, 0x1b, 0x40, 0xd3, 0x08, 0xc7, 0x61, 0x5f, 0x76, 0x36, 0xab, 0xc2, 0x80,
	0x55, 0x85, 0x01, 0xd1, 0xc2, 0xd0, 0xb4, 0x53, 0x2f, 0x64, 0x30, 0xea, 0x9c, 0xaa, 0x4d, 0x1d,
	0xc0, 0xda, 0xd4, 0x01, 0x32, 0x53, 0x87, 0xb6, 0x51, 0x30, 0x84, 0x3c, 0xd5, 0x61, 0x55, 0x05,
	0x08, 0x56, 0x15, 0x20, 0xa4, 0x15, 0x60, 0xdb, 0x7b, 0xc0, 0xce, 0x58, 0x42, 0x2d, 0xa2, 0x8d,
	0x5a, 0xde, 0x98, 0x96, 0x7e, 0x8d, 0x33, 0x2b, 0xfd, 0x97, 0x6a, 0xaa, 0xf4, 0x82, 0x6a, 0x1d,
	0xf9, 0xcf, 0x9a, 0xec, 0xe2, 0x6e, 0x3a, 0xfe, 0x66, 0x26, 0x3f, 0x3c, 0x61, 0x39, 0xe1, 0xfd,
	0x5a, 0x4e, 0xb8, 0x5a, 0xcf, 0x09, 0xf5, 0x35, 0x2d, 0x97, 0x17, 0x1e, 0xb1, 0xed, 0x05, 0xb2,
	0xd6, 0xfd, 0xa9, 0x94, 0x03, 0x9d, 0x14, 0xc8, 0xfd, 0x00, 0xd6, 0xdc, 0x0f, 0x90, 0x71, 0x3f,
	0xb6, 0x7f, 0xda, 0x64, 0x17, 0xba, 0x32, 0x4a, 0xb2, 0xc9, 0x09, 0xb3, 0xf3, 0xc3, 0x9a, 0x9d,
	0xfd, 0xca, 0x70, 0xf3, 0x4b, 0x5a, 0xce, 0xcc, 0xff, 0x58, 0x65, 0xde, 0xbc, 0x2c, 0x64, 0xe0,
	0x48, 0x46, 0x47, 0x65, 0xe0, 0x1a, 0x8b, 0x32, 0x70, 0x8d, 0xc1, 0x45, 0xbd, 0x2b, 0xf8, 0x0f,
	0xa0, 0x22, 0x29, 0x82, 0x91, 0x4e, 0xc0, 0xe8, 0x3f, 0x0b, 0x92, 0xff, 0x2c, 0xc4, 0x05, 0xb1,
	0x21, 0x79, 0xa0, 0xce, 0x5c, 0x0e, 0xdc, 0xec, 0x6b, 0x30, 0x4a, 0x1e, 0x06, 0xe1, 0xc2, 0x32,
	0x8d, 0xf0, 0x7e, 0x26, 0xa5, 0xce, 0xbd, 0x56, 0x18, 0xb0, 0xaa, 0x30, 0x20, 0x5a, 0x18, 0x9a,
	0x90, 0xba, 0xa1, 0x9d, 0x1f, 0x04, 0x99, 0x1c, 0xe8, 0xb4, 0x8b, 0xa9, 0x9b, 0x50, 0x4a, 0xdd,
	0x84, 0x71, 0xe1, 0x74, 0x50, 0x17, 0x88, 0xa8, 0xb7, 0x37, 0xde, 0xdf, 0x97, 0x59, 0xae, 0x73,
	0xaf, 0xbe, 0x40, 0x58, 0xd8, 0xbd, 0x40, 0x58, 0x10, 0x2f, 0x10, 0x96, 0x32, 0xb3, 0xe9, 0x07,
	0xfd, 0x03, 0x39, 0xd0, 0x39, 0xd8, 0xce, 0x46, 0xa1, 0xd5, 0xd9, 0x28, 0x4c, 0xcf, 0x46, 0x13,
	0x3f, 0x6e, 0xb2, 0xce, 0xed, 0x30, 0x3f, 0x3c, 0x61, 0x5b, 0x41, 0xd4, 0xb6, 0xc2, 0xe5, 0xca,
	0x70, 0xf5, 0x05, 0x2d, 0xb7, 0x11, 0x7e, 0xd3, 0x62, 0x67, 0xeb, 0x92, 0x10, 0xad, 0x83, 0x30,
	0x3f, 0x54, 0x01, 0xe3, 0x64, 0x1b, 0x0b, 0x52, 0xb4, 0x5a, 0x88, 0x0b, 0x62, 0x83, 0x97, 0x90,
	0x70, 0xe3, 0x1d, 0xbd, 0x44, 0x28, 0x79, 0x89, 0x30, 0x2e, 0x9c, 0x0e, 0x76, 0x16, 0x4e, 0xcc,
	0xd3, 0x2c, 0x74, 0xd0, 0xbb, 0xb3, 0x50, 0x51, 0x4f, 0x6c, 0xef, 0xbb, 0xec, 0xac, 0x22, 0x9c,
	0xed, 0xac, 0xc2, 0xff, 0xfa, 0xb4, 0xf4, 0xe7, 0x78, 0xb3, 0xd2, 0xdf, 0x71, 0xd5, 0xb9, 0x1b,
	0x7a, 0xae, 0x33, 0xdc, 0xdc, 0x0f, 0xf7, 0x7a, 0x99, 0x0c, 0xcc, 0x9e, 0xc0, 0x9b, 0xbb, 0x86,
	0xe8, 0xe6, 0xae, 0x01, 0x2e, 0x0c, 0x0b, 0x6c, 0x73, 0xb8, 0xd7, 0x7b, 0x92, 0x85, 0x45, 0x21,
	0x63, 0xbd, 0x13, 0xd0, 0x36, 0x84, 0x92, 0x6d, 0x08, 0xe3, 0xc2, 0xe9, 0x00, 0x3b, 0x3a, 0x49,
	0x73, 0x35, 0xbc, 0x73, 0x11, 0x31, 0x18, 0xed, 0x68, 0x83, 0x70, 0x61, 0x99, 0x60, 0x58, 0x68,
	0x83, 0x2e, 0x73, 0x13, 0x41, 0xc3, 0x5a, 0x90, 0x0c, 0x6b, 0x21, 0x2e, 0x88, 0x8d, 0xa7, 0xf6,
	0x7b, 0xb2, 0x78, 0x92, 0x64, 0x87, 0x9f, 0xa9, 0x53, 0x7b, 0xc1, 0x9a, 0x96, 0xdb, 0x45, 0x3f,
	0x69, 0xb2, 0xed, 0x05, 0xc2, 0xe0, 0xa6, 0xbd, 0x49, 0x21, 0xf3, 0x5e, 0x68, 0x0e, 0x12, 0x74,
	0x93, 0xc1, 0xc8, 0x4d, 0x06, 0xe1, 0xc2, 0x32, 0xc1, 0x4d, 0xaa, 0x9d, 0x8c, 0x0b, 0xf7, 0xcc,
	0xb0, 0x20, 0xb9, 0xc9, 0x42, 0x5c, 0x10, 0x1b, 0x42, 0x34, 0x3d, 0x2c, 0x70, 0xf0, 0x55, 0x0a,
	0x51, 0x0d, 0x51, 0x88, 0x6a, 0x80, 0x0b, 0xc3, 0x82, 0x69, 0x63, 0x13, 0x06, 0x76, 0xce, 0x0b,
	0x83, 0xd1, 0xb4, 0x0d, 0xc2, 0x85, 0x65, 0xf2, 0x9f, 0x37, 0xd9, 0xb6, 0xae, 0x8c, 0x2b, 0x41,
	0x71, 0x93, 0xad, 0x67, 0x32, 0x1f, 0x8f, 0x0a, 0x1d, 0x16, 0x68, 0x58, 0x85, 0x90, 0x61, 0x15,
	0xcd, 0x85, 0x66, 0x80, 0x73, 0xc7, 0x71, 0x58, 0xe8, 0xe2, 0x18, 0x9d, 0x0b, 0x34, 0x39, 0x17,
	0x28, 0x2e, 0x10, 0x84, 0xce, 0x03, 0x99, 0xf7, 0xdd, 0x48, 0x00, 0x9a, 0x3a, 0x03, 0xc5, 0x05,
	0x82, 0x60, 0x1c, 0x39, 0x0a, 0x52, 0xc8, 0x2d, 0x2d, 0xaa, 0xbc, 0x35, 0x44, 0xc6, 0xd1, 0x00,
	0x17, 0x86, 0xe5, 0xbd, 0xc5, 0x36, 0xf2, 0x54, 0xf6, 0xa1, 0xf6, 0x5e, 0xa3, 0x85, 0x00, 0x14,
	0x3a, 0xdf, 0xba, 0x14, 0xcd, 0x85, 0x66, 0xf0, 0xdf, 0x37, 0xb0, 0xde, 0x7b, 0x76, 0xdb, 0xe4,
	0xae, 0x8d, 0xfc, 0xd5, 0xab, 0xab, 0xd7, 0xda, 0x37, 0xce, 0xd7, 0xef, 0xab, 0xcb, 0x47, 0xfb,
	0xaf, 0xd6, 0xd9, 0x86, 0x16, 0x78, 0x51, 0xb3, 0xbe, 0xa8, 0x59, 0x9f, 0xb3, 0x9a, 0xd5, 0x1e,
	0x38, 0xa7, 0x97, 0x38, 0x70, 0xf8, 0x9f, 0x1b, 0xb6, 0xa0, 0x7b, 0x76, 0x7b, 0xbf, 0x5b, 0xdb,
	0xfb, 0x9d, 0x45, 0xb5, 0xea, 0xf2, 0xfb, 0xff, 0x87, 0xac, 0xed, 0xc8, 0xfc, 0xc7, 0xb5, 0xa9,
	0x35, 0x68, 0x73, 0x19, 0x83, 0xfe, 0xb1, 0x61, 0x2a, 0xb7, 0x67, 0x67, 0xcf, 0x6f, 0xd7, 0xec,
	0xb9, 0xb3, 0xa0, 0x26, 0x5d, 0xde, 0x9c, 0xbf, 0x6c, 0x31, 0x46, 0x32, 0x2f, 0x6a, 0xd0, 0xe7,
	0xa2, 0x06, 0xb5, 0x41, 0xbf, 0xb9, 0x4c, 0xd0, 0xff, 0xa1, 0xa1, 0xaa, 0xb4, 0x67, 0x17, 0xf2,
	0xef, 0xd6, 0x42, 0xfe, 0xa5, 0xb9, 0xda, 0xf3, 0x53, 0xdc, 0x96, 0xd7, 0xd8, 0xa6, 0x91, 0x80,
	0x55, 0x38, 0x65, 0x26, 0xce, 0x42, 0xc7, 0x83, 0x9e, 0x85, 0x8a, 0x85, 0x96, 0x89, 0x03, 0xa8,
	0x60, 0x7a, 0x78, 0xc7, 0x75, 0x2f, 0x05, 0x84, 0x92, 0xe5, 0x09, 0xe3, 0xc2, 0xe9, 0x00, 0xfb,
	0x00, 0x29, 0x5b, 0x35, 0xe8, 0x7d, 0x60, 0x41, 0xda, 0x07, 0x16, 0xe2, 0x82, 0xd8, 0xde, 0x75,
	0xb6, 0x06, 0x44, 0xae, 0xe3, 0x18, 0xff, 0x7b, 0x41, 0x80, 0xfe, 0x7b, 0x41, 0x92, 0x0b, 0x05,
	0x83, 0x80, 0xda, 0x75, 0x6b, 0x24, 0x60, 0x76, 0x9c, 0x16, 0xd0, 0xbb, 0x4d, 0xc1, 0x78, 0xed,
	0x85, 0x5d, 0xb6, 0x4e, 0x46, 0xd1, 0x3b, 0xcc, 0x5c, 0x7b, 0x71, 0x77, 0x21, 0xe8, 0x7d, 0x8b,
	0x9d, 0x86, 0xdf, 0x5e, 0x2a, 0xb3, 0xbe, 0x8c, 0x0b, 0x1d, 0x90, 0xaf, 0x4f, 0x4b, 0xbf, 0x82,
	0xcf, 0x4a, 0x7f, 0x9b, 0x84, 0x0d, 0xca, 0x45, 0xa5, 0x13, 0x6c, 0x12, 0xac, 0xf1, 0xb4, 0x89,
	0x37, 0x69, 0x93, 0x38, 0x30, 0x6d, 0x12, 0x07, 0xe4, 0xc2, 0xed, 0x02, 0xae, 0x52, 0x24, 0x9a,
	0xf9, 0x14, 0xb9, 0x8a, 0x50, 0x72, 0x15, 0x61, 0x5c, 0x38, 0x1d, 0xa0, 0x66, 0x40, 0x2a, 0xd7,
	0xa7, 0x3f, 0x86, 0x97, 0x42, 0x28, 0xbc, 0x14, 0xcd, 0x85, 0x66, 0xd8, 0x9d, 0xd5, 0x5e, 0xf6,
	0x7c, 0xd6, 0x95, 0xdb, 0xff, 0xeb, 0xf9, 0xec, 0x4c, 0x6f, 0xb9, 0xfd, 0xf5, 0xeb, 0x26, 0x6b,
	0x3b, 0x42, 0xcf, 0x63, 0x15, 0x6a, 0x83, 0x60, 0x6d, 0x99, 0x20, 0x48, 0xd8, 0x4e, 0x37, 0x89,
	0xc3, 0x22, 0xc9, 0xc2, 0x78, 0xb8, 0x9b, 0xc4, 0xfb, 0xe1, 0xd0, 0xfc, 0xa3, 0xfb, 0x90, 0xb5,
	0x42, 0x28, 0x40, 0x1a, 0xe8, 0xda, 0x57, 0xaa, 0x07, 0x7d, 0x4d, 0x86, 0x3c, 0xd4, 0x4f, 0xa2,
	0x08, 0x0f, 0x67, 0xed, 0x21, 0x45, 0x73, 0xa1, 0x19, 0x3c, 0x65, 0x9d, 0xf9, 0x01, 0x75, 0xe4,
	0xfd, 0x6f, 0x46, 0xfc, 0x68, 0x95, 0x9d, 0x5f, 0x24, 0x0d, 0x57, 0x64, 0xfd, 0x37, 0x6f, 0x5c,
	0xc8, 0xec, 0x71, 0x30, 0xc2, 0x81, 0xd7, 0xd4, 0x15, 0xb9, 0xca, 0xa1, 0x2b, 0x72, 0x15, 0xe7,
	0xa2, 0xd6, 0xd1, 0xeb, 0x33, 0xaf, 0x9f, 0x8c, 0x46, 0xb2, 0x5f, 0x24, 0x19, 0x29, 0x6e, 0xa2,
	0x62, 0x7c, 0xb5, 0x30, 0xcf, 0xa5, 0x57, 0x0b, 0xf3, 0x3c, 0x2e, 0x16, 0x08, 0xc0, 0xcc, 0xa3,
	0xe0, 0xfb, 0xbd, 0x83, 0x24, 0x2f, 0x7a, 0xfd, 0x64, 0x1c, 0xab, 0x28, 0xd1, 0x33, 0xaf, 0x72,
	0x68, 0xe6, 0x55, 0x9c, 0x8b, 0x5a, 0x47, 0xaf, 0xc7, 0xce, 0x45, 0xd6, 0x4c, 0xbd, 0x34, 0x19,
	0x85, 0xfd, 0x89, 0x0e, 0xa2, 0x2f, 0x4f, 0x4b, 0x7f, 0x9e, 0x39, 0x2b, 0xfd, 0x8e, 0x56, 0x5d,
	0x67, 0x71, 0x31, 0xdf, 0x9d, 0xff, 0x65, 0x95, 0x6d, 0xdf, 0x8d, 0xf3, 0x22, 0x18, 0x8d, 0xbe,
	0x0e, 0x46, 0x3b, 0x01, 0x4f, 0x07, 0xde, 0x61, 0xa7, 0xd2, 0xf1, 0xde, 0x28, 0xec, 0xd3, 0xdb,
	0x01, 0x4c, 0x01, 0x16, 0xa4, 0x14, 0x60, 0x21, 0x2e, 0x88, 0x0d, 0x0a, 0xa0, 0x9a, 0x74, 0x1f,
	0x0f, 0xa0, 0x02, 0x0b, 0x92, 0x02, 0x0b, 0x71, 0x41, 0x6c, 0x58, 0x6b, 0x9e, 0x1f, 0xf4, 0x0e,
	0xe5, 0x44, 0xbf, 0x4f, 0xc1, 0xb5, 0x6a, 0x88, 0xd6, 0xaa, 0x01, 0x2e, 0x0c, 0x0b, 0xeb, 0xd7,
	0x3c, 0x55, 0x4f, 0x70, 0x36, 0xe8, 0xd5, 0x83, 0xc1, 0x9c, 0xfa, 0x55, 0x23, 0x50, 0xbf, 0xea,
	0x26, 0xe4, 0x90, 0x34, 0xc9, 0x0a, 0xf7, 0x8a, 0x06, 0x34, 0xe5, 0x10, 0xa0, 0xb8, 0x40, 0xf0,
	0xc6, 0x3f, 0x19, 0x5b, 0xed, 0xde, 0x7b, 0xcf, 0x7b, 0xc4, 0xce, 0xdc, 0x91, 0x85, 0xf3, 0x01,
	0xcc, 0xab, 0x7e, 0x63, 0x5c, 0xf0, 0x6c, 0xe4, 0x42, 0xb5, 0xc7, 0x82, 0x8f, 0x67, 0x7c, 0xc5,
	0x1b, 0xb2, 0x9d, 0x3b, 0xb2, 0xa8, 0x3c, 0xb4, 0x31, 0xdf, 0x60, 0x5e, 0xad, 0x0d, 0xb0, 0xf0,
	0x2d, 0xce, 0x85, 0x57, 0x8f, 0x7b, 0xb4, 0xe0, 0x0c, 0x94, 0xb0, 0x8b, 0x0b, 0x06, 0xb2, 0xd5,
	0xde, 0x72, 0x83, 0x5d, 0xfb, 0xa4, 0x7f, 0x43, 0x9d, 0x01, 0x23, 0x76, 0xa1, 0x3e, 0xa0, 0x53,
	0x0e, 0x2d, 0x37, 0xde, 0xeb, 0x9f, 0xf0, 0xaf, 0xa0, 0x33, 0x5c, 0xc8, 0x3a, 0xf5, 0xe1, 0xec,
	0x65, 0x74, 0xb9, 0xc1, 0x5e, 0x3b, 0xf6, 0x7f, 0x97, 0xe3, 0x4d, 0xe9, 0x9e, 0xcb, 0xff, 0x8e,
	0x29, 0x8f, 0xf9, 0xec, 0xce, 0x57, 0xbc, 0x7b, 0x6c, 0x0b, 0x07, 0x74, 0x82, 0xe3, 0x52, 0x3d,
	0xfa, 0x2a, 0xca, 0x2f, 0x2d, 0xfa, 0x0a, 0xe8, 0x28, 0xfc, 0x80, 0x6d, 0x3b, 0x0a, 0x6d, 0x10,
	0x1c, 0xaf, 0xf4, 0xea, 0x51, 0x9f, 0x17, 0x1c, 0xc5, 0xef, 0x33, 0xcf, 0x28, 0x76, 0x9c, 0x7d,
	0xbc, 0x5e, 0xff, 0x88, 0x32, 0xdb, 0x51, 0x7b, 0x9f, 0x9d, 0x35, 0x6a, 0xad, 0x53, 0x8f, 0x57,
	0x7a, 0x79, 0x61, 0x21, 0xb3, 0xd8, 0x04, 0xae, 0xf3, 0x3e, 0x8d, 0x09, 0x16, 0x5c, 0x30, 0xf9,
	0x8a, 0xf7, 0x3d, 0x76, 0xfa, 0x81, 0x2c, 0xc0, 0xb2, 0x78, 0x1a, 0xd7, 0xc2, 0xe1, 0x88, 0x0b,
	0x49, 0x2d, 0xf8, 0x8e, 0xba, 0x45, 0xf0, 0x15, 0x28, 0x0b, 0xee, 0xb8, 0xea, 0xbd, 0x8a, 0x20,
	0x3e, 0x1d, 0x5d, 0x5e, 0x59, 0x97, 0x9d, 0x11, 0x32, 0xff, 0xaf, 0xa9, 0xfb, 0x0e, 0x3b, 0xed,
	0x9e, 0x81, 0xb5, 0x14, 0xb9, 0xe0, 0x78, 0xac, 0x05, 0x6a, 0xed, 0xbd, 0x2b, 0x5f, 0xb9, 0x75,
	0xf6, 0x77, 0x4f, 0xaf, 0x34, 0xfe, 0xf4, 0xf4, 0x4a, 0xe3, 0xaf, 0x4f, 0xaf, 0x34, 0x3e, 0xfe,
	0xdb, 0x95, 0x95, 0xbd, 0x75, 0x7c, 0x26, 0x7b, 0xf3, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xb9,
	0x17, 0xe9, 0x6c, 0x6a, 0x2b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MONClient is the client API for MON service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MONClient interface {
	// TODO: MCIS 모니터링 조회
	GetMCISMonInfo(ctx context.Context, in *VMMCISMonQryRequest, opts ...grpc.CallOption) (*MCISMonInfoResponse, error)
	// VM 온디멘드 모니터링 조회
	GetVMOnDemandMonCpuInfo(ctx context.Context, in *VMOnDemandMonQryRequest, opts ...grpc.CallOption) (*CpuOnDemandInfoResponse, error)
	GetVMOnDemandMonCpuFreqInfo(ctx context.Context, in *VMOnDemandMonQryRequest, opts ...grpc.CallOption) (*CpuFreqOnDemandInfoResponse, error)
	GetVMOnDemandMonMemoryInfo(ctx context.Context, in *VMOnDemandMonQryRequest, opts ...grpc.CallOption) (*MemoryOnDemandInfoResponse, error)
	GetVMOnDemandMonDiskInfo(ctx context.Context, in *VMOnDemandMonQryRequest, opts ...grpc.CallOption) (*DiskOnDemandInfoResponse, error)
	GetVMOnDemandMonNetworkInfo(ctx context.Context, in *VMOnDemandMonQryRequest, opts ...grpc.CallOption) (*NetworkOnDemandInfoResponse, error)
	// VM 모니터링 조회
	GetVMMonCpuInfo(ctx context.Context, in *VMMonQryRequest, opts ...grpc.CallOption) (*CpuInfoResponse, error)
	GetVMMonCpuFreqInfo(ctx context.Context, in *VMMonQryRequest, opts ...grpc.CallOption) (*CpuFreqInfoResponse, error)
	GetVMMonMemoryInfo(ctx context.Context, in *VMMonQryRequest, opts ...grpc.CallOption) (*MemoryInfoResponse, error)
	GetVMMonDiskInfo(ctx context.Context, in *VMMonQryRequest, opts ...grpc.CallOption) (*DiskInfoResponse, error)
	GetVMMonNetworkInfo(ctx context.Context, in *VMMonQryRequest, opts ...grpc.CallOption) (*NetworkInfoResponse, error)
	SetMonConfig(ctx context.Context, in *MonitoringConfigRequest, opts ...grpc.CallOption) (*MonitoringConfigResponse, error)
	GetMonConfig(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MonitoringConfigResponse, error)
	ResetMonConfig(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MonitoringConfigResponse, error)
	InstallAgent(ctx context.Context, in *InstallAgentRequest, opts ...grpc.CallOption) (*MessageResponse, error)
}

type mONClient struct {
	cc *grpc.ClientConn
}

func NewMONClient(cc *grpc.ClientConn) MONClient {
	return &mONClient{cc}
}

func (c *mONClient) GetMCISMonInfo(ctx context.Context, in *VMMCISMonQryRequest, opts ...grpc.CallOption) (*MCISMonInfoResponse, error) {
	out := new(MCISMonInfoResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/GetMCISMonInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) GetVMOnDemandMonCpuInfo(ctx context.Context, in *VMOnDemandMonQryRequest, opts ...grpc.CallOption) (*CpuOnDemandInfoResponse, error) {
	out := new(CpuOnDemandInfoResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/GetVMOnDemandMonCpuInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) GetVMOnDemandMonCpuFreqInfo(ctx context.Context, in *VMOnDemandMonQryRequest, opts ...grpc.CallOption) (*CpuFreqOnDemandInfoResponse, error) {
	out := new(CpuFreqOnDemandInfoResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/GetVMOnDemandMonCpuFreqInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) GetVMOnDemandMonMemoryInfo(ctx context.Context, in *VMOnDemandMonQryRequest, opts ...grpc.CallOption) (*MemoryOnDemandInfoResponse, error) {
	out := new(MemoryOnDemandInfoResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/GetVMOnDemandMonMemoryInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) GetVMOnDemandMonDiskInfo(ctx context.Context, in *VMOnDemandMonQryRequest, opts ...grpc.CallOption) (*DiskOnDemandInfoResponse, error) {
	out := new(DiskOnDemandInfoResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/GetVMOnDemandMonDiskInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) GetVMOnDemandMonNetworkInfo(ctx context.Context, in *VMOnDemandMonQryRequest, opts ...grpc.CallOption) (*NetworkOnDemandInfoResponse, error) {
	out := new(NetworkOnDemandInfoResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/GetVMOnDemandMonNetworkInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) GetVMMonCpuInfo(ctx context.Context, in *VMMonQryRequest, opts ...grpc.CallOption) (*CpuInfoResponse, error) {
	out := new(CpuInfoResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/GetVMMonCpuInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) GetVMMonCpuFreqInfo(ctx context.Context, in *VMMonQryRequest, opts ...grpc.CallOption) (*CpuFreqInfoResponse, error) {
	out := new(CpuFreqInfoResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/GetVMMonCpuFreqInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) GetVMMonMemoryInfo(ctx context.Context, in *VMMonQryRequest, opts ...grpc.CallOption) (*MemoryInfoResponse, error) {
	out := new(MemoryInfoResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/GetVMMonMemoryInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) GetVMMonDiskInfo(ctx context.Context, in *VMMonQryRequest, opts ...grpc.CallOption) (*DiskInfoResponse, error) {
	out := new(DiskInfoResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/GetVMMonDiskInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) GetVMMonNetworkInfo(ctx context.Context, in *VMMonQryRequest, opts ...grpc.CallOption) (*NetworkInfoResponse, error) {
	out := new(NetworkInfoResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/GetVMMonNetworkInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) SetMonConfig(ctx context.Context, in *MonitoringConfigRequest, opts ...grpc.CallOption) (*MonitoringConfigResponse, error) {
	out := new(MonitoringConfigResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/SetMonConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) GetMonConfig(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MonitoringConfigResponse, error) {
	out := new(MonitoringConfigResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/GetMonConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) ResetMonConfig(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MonitoringConfigResponse, error) {
	out := new(MonitoringConfigResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/ResetMonConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) InstallAgent(ctx context.Context, in *InstallAgentRequest, opts ...grpc.CallOption) (*MessageResponse, error) {
	out := new(MessageResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/InstallAgent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MONServer is the server API for MON service.
type MONServer interface {
	// TODO: MCIS 모니터링 조회
	GetMCISMonInfo(context.Context, *VMMCISMonQryRequest) (*MCISMonInfoResponse, error)
	// VM 온디멘드 모니터링 조회
	GetVMOnDemandMonCpuInfo(context.Context, *VMOnDemandMonQryRequest) (*CpuOnDemandInfoResponse, error)
	GetVMOnDemandMonCpuFreqInfo(context.Context, *VMOnDemandMonQryRequest) (*CpuFreqOnDemandInfoResponse, error)
	GetVMOnDemandMonMemoryInfo(context.Context, *VMOnDemandMonQryRequest) (*MemoryOnDemandInfoResponse, error)
	GetVMOnDemandMonDiskInfo(context.Context, *VMOnDemandMonQryRequest) (*DiskOnDemandInfoResponse, error)
	GetVMOnDemandMonNetworkInfo(context.Context, *VMOnDemandMonQryRequest) (*NetworkOnDemandInfoResponse, error)
	// VM 모니터링 조회
	GetVMMonCpuInfo(context.Context, *VMMonQryRequest) (*CpuInfoResponse, error)
	GetVMMonCpuFreqInfo(context.Context, *VMMonQryRequest) (*CpuFreqInfoResponse, error)
	GetVMMonMemoryInfo(context.Context, *VMMonQryRequest) (*MemoryInfoResponse, error)
	GetVMMonDiskInfo(context.Context, *VMMonQryRequest) (*DiskInfoResponse, error)
	GetVMMonNetworkInfo(context.Context, *VMMonQryRequest) (*NetworkInfoResponse, error)
	SetMonConfig(context.Context, *MonitoringConfigRequest) (*MonitoringConfigResponse, error)
	GetMonConfig(context.Context, *Empty) (*MonitoringConfigResponse, error)
	ResetMonConfig(context.Context, *Empty) (*MonitoringConfigResponse, error)
	InstallAgent(context.Context, *InstallAgentRequest) (*MessageResponse, error)
}

// UnimplementedMONServer can be embedded to have forward compatible implementations.
type UnimplementedMONServer struct {
}

func (*UnimplementedMONServer) GetMCISMonInfo(ctx context.Context, req *VMMCISMonQryRequest) (*MCISMonInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMCISMonInfo not implemented")
}
func (*UnimplementedMONServer) GetVMOnDemandMonCpuInfo(ctx context.Context, req *VMOnDemandMonQryRequest) (*CpuOnDemandInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVMOnDemandMonCpuInfo not implemented")
}
func (*UnimplementedMONServer) GetVMOnDemandMonCpuFreqInfo(ctx context.Context, req *VMOnDemandMonQryRequest) (*CpuFreqOnDemandInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVMOnDemandMonCpuFreqInfo not implemented")
}
func (*UnimplementedMONServer) GetVMOnDemandMonMemoryInfo(ctx context.Context, req *VMOnDemandMonQryRequest) (*MemoryOnDemandInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVMOnDemandMonMemoryInfo not implemented")
}
func (*UnimplementedMONServer) GetVMOnDemandMonDiskInfo(ctx context.Context, req *VMOnDemandMonQryRequest) (*DiskOnDemandInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVMOnDemandMonDiskInfo not implemented")
}
func (*UnimplementedMONServer) GetVMOnDemandMonNetworkInfo(ctx context.Context, req *VMOnDemandMonQryRequest) (*NetworkOnDemandInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVMOnDemandMonNetworkInfo not implemented")
}
func (*UnimplementedMONServer) GetVMMonCpuInfo(ctx context.Context, req *VMMonQryRequest) (*CpuInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVMMonCpuInfo not implemented")
}
func (*UnimplementedMONServer) GetVMMonCpuFreqInfo(ctx context.Context, req *VMMonQryRequest) (*CpuFreqInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVMMonCpuFreqInfo not implemented")
}
func (*UnimplementedMONServer) GetVMMonMemoryInfo(ctx context.Context, req *VMMonQryRequest) (*MemoryInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVMMonMemoryInfo not implemented")
}
func (*UnimplementedMONServer) GetVMMonDiskInfo(ctx context.Context, req *VMMonQryRequest) (*DiskInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVMMonDiskInfo not implemented")
}
func (*UnimplementedMONServer) GetVMMonNetworkInfo(ctx context.Context, req *VMMonQryRequest) (*NetworkInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVMMonNetworkInfo not implemented")
}
func (*UnimplementedMONServer) SetMonConfig(ctx context.Context, req *MonitoringConfigRequest) (*MonitoringConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMonConfig not implemented")
}
func (*UnimplementedMONServer) GetMonConfig(ctx context.Context, req *Empty) (*MonitoringConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMonConfig not implemented")
}
func (*UnimplementedMONServer) ResetMonConfig(ctx context.Context, req *Empty) (*MonitoringConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetMonConfig not implemented")
}
func (*UnimplementedMONServer) InstallAgent(ctx context.Context, req *InstallAgentRequest) (*MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstallAgent not implemented")
}

func RegisterMONServer(s *grpc.Server, srv MONServer) {
	s.RegisterService(&_MON_serviceDesc, srv)
}

func _MON_GetMCISMonInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMMCISMonQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).GetMCISMonInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/GetMCISMonInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).GetMCISMonInfo(ctx, req.(*VMMCISMonQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_GetVMOnDemandMonCpuInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMOnDemandMonQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).GetVMOnDemandMonCpuInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/GetVMOnDemandMonCpuInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).GetVMOnDemandMonCpuInfo(ctx, req.(*VMOnDemandMonQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_GetVMOnDemandMonCpuFreqInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMOnDemandMonQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).GetVMOnDemandMonCpuFreqInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/GetVMOnDemandMonCpuFreqInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).GetVMOnDemandMonCpuFreqInfo(ctx, req.(*VMOnDemandMonQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_GetVMOnDemandMonMemoryInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMOnDemandMonQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).GetVMOnDemandMonMemoryInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/GetVMOnDemandMonMemoryInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).GetVMOnDemandMonMemoryInfo(ctx, req.(*VMOnDemandMonQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_GetVMOnDemandMonDiskInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMOnDemandMonQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).GetVMOnDemandMonDiskInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/GetVMOnDemandMonDiskInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).GetVMOnDemandMonDiskInfo(ctx, req.(*VMOnDemandMonQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_GetVMOnDemandMonNetworkInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMOnDemandMonQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).GetVMOnDemandMonNetworkInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/GetVMOnDemandMonNetworkInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).GetVMOnDemandMonNetworkInfo(ctx, req.(*VMOnDemandMonQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_GetVMMonCpuInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMMonQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).GetVMMonCpuInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/GetVMMonCpuInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).GetVMMonCpuInfo(ctx, req.(*VMMonQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_GetVMMonCpuFreqInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMMonQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).GetVMMonCpuFreqInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/GetVMMonCpuFreqInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).GetVMMonCpuFreqInfo(ctx, req.(*VMMonQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_GetVMMonMemoryInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMMonQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).GetVMMonMemoryInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/GetVMMonMemoryInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).GetVMMonMemoryInfo(ctx, req.(*VMMonQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_GetVMMonDiskInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMMonQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).GetVMMonDiskInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/GetVMMonDiskInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).GetVMMonDiskInfo(ctx, req.(*VMMonQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_GetVMMonNetworkInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMMonQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).GetVMMonNetworkInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/GetVMMonNetworkInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).GetVMMonNetworkInfo(ctx, req.(*VMMonQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_SetMonConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MonitoringConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).SetMonConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/SetMonConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).SetMonConfig(ctx, req.(*MonitoringConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_GetMonConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).GetMonConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/GetMonConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).GetMonConfig(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_ResetMonConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).ResetMonConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/ResetMonConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).ResetMonConfig(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_InstallAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstallAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).InstallAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/InstallAgent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).InstallAgent(ctx, req.(*InstallAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _MON_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cbdragonfly.MON",
	HandlerType: (*MONServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMCISMonInfo",
			Handler:    _MON_GetMCISMonInfo_Handler,
		},
		{
			MethodName: "GetVMOnDemandMonCpuInfo",
			Handler:    _MON_GetVMOnDemandMonCpuInfo_Handler,
		},
		{
			MethodName: "GetVMOnDemandMonCpuFreqInfo",
			Handler:    _MON_GetVMOnDemandMonCpuFreqInfo_Handler,
		},
		{
			MethodName: "GetVMOnDemandMonMemoryInfo",
			Handler:    _MON_GetVMOnDemandMonMemoryInfo_Handler,
		},
		{
			MethodName: "GetVMOnDemandMonDiskInfo",
			Handler:    _MON_GetVMOnDemandMonDiskInfo_Handler,
		},
		{
			MethodName: "GetVMOnDemandMonNetworkInfo",
			Handler:    _MON_GetVMOnDemandMonNetworkInfo_Handler,
		},
		{
			MethodName: "GetVMMonCpuInfo",
			Handler:    _MON_GetVMMonCpuInfo_Handler,
		},
		{
			MethodName: "GetVMMonCpuFreqInfo",
			Handler:    _MON_GetVMMonCpuFreqInfo_Handler,
		},
		{
			MethodName: "GetVMMonMemoryInfo",
			Handler:    _MON_GetVMMonMemoryInfo_Handler,
		},
		{
			MethodName: "GetVMMonDiskInfo",
			Handler:    _MON_GetVMMonDiskInfo_Handler,
		},
		{
			MethodName: "GetVMMonNetworkInfo",
			Handler:    _MON_GetVMMonNetworkInfo_Handler,
		},
		{
			MethodName: "SetMonConfig",
			Handler:    _MON_SetMonConfig_Handler,
		},
		{
			MethodName: "GetMonConfig",
			Handler:    _MON_GetMonConfig_Handler,
		},
		{
			MethodName: "ResetMonConfig",
			Handler:    _MON_ResetMonConfig_Handler,
		},
		{
			MethodName: "InstallAgent",
			Handler:    _MON_InstallAgent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cbdragonfly/cbdragonfly.proto",
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *MessageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tags) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tags) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tags) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VmId) > 0 {
		i -= len(m.VmId)
		copy(dAtA[i:], m.VmId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.VmId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.McisId) > 0 {
		i -= len(m.McisId)
		copy(dAtA[i:], m.McisId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.McisId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NsId) > 0 {
		i -= len(m.NsId)
		copy(dAtA[i:], m.NsId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.NsId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VMMonQryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VMMonQryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VMMonQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Duration) > 0 {
		i -= len(m.Duration)
		copy(dAtA[i:], m.Duration)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Duration)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.StatisticsCriteria) > 0 {
		i -= len(m.StatisticsCriteria)
		copy(dAtA[i:], m.StatisticsCriteria)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.StatisticsCriteria)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PeriodType) > 0 {
		i -= len(m.PeriodType)
		copy(dAtA[i:], m.PeriodType)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.PeriodType)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.VmId) > 0 {
		i -= len(m.VmId)
		copy(dAtA[i:], m.VmId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.VmId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.McisId) > 0 {
		i -= len(m.McisId)
		copy(dAtA[i:], m.McisId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.McisId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NsId) > 0 {
		i -= len(m.NsId)
		copy(dAtA[i:], m.NsId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.NsId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VMOnDemandMonQryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VMOnDemandMonQryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VMOnDemandMonQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AgentIp) > 0 {
		i -= len(m.AgentIp)
		copy(dAtA[i:], m.AgentIp)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.AgentIp)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.VmId) > 0 {
		i -= len(m.VmId)
		copy(dAtA[i:], m.VmId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.VmId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.McisId) > 0 {
		i -= len(m.McisId)
		copy(dAtA[i:], m.McisId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.McisId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NsId) > 0 {
		i -= len(m.NsId)
		copy(dAtA[i:], m.NsId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.NsId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VMMCISMonQryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VMMCISMonQryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VMMCISMonQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MetricName) > 0 {
		i -= len(m.MetricName)
		copy(dAtA[i:], m.MetricName)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.MetricName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AgentIp) > 0 {
		i -= len(m.AgentIp)
		copy(dAtA[i:], m.AgentIp)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.AgentIp)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.VmId) > 0 {
		i -= len(m.VmId)
		copy(dAtA[i:], m.VmId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.VmId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.McisId) > 0 {
		i -= len(m.McisId)
		copy(dAtA[i:], m.McisId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.McisId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NsId) > 0 {
		i -= len(m.NsId)
		copy(dAtA[i:], m.NsId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.NsId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CpuOnDemandInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CpuOnDemandInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CpuOnDemandInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Values != nil {
		{
			size, err := m.Values.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Tags != nil {
		{
			size, err := m.Tags.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CpuOnDemandInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CpuOnDemandInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CpuOnDemandInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CpuGuestNice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuGuestNice))))
		i--
		dAtA[i] = 0x59
	}
	if m.CpuGuest != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuGuest))))
		i--
		dAtA[i] = 0x51
	}
	if m.CpuSteal != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuSteal))))
		i--
		dAtA[i] = 0x49
	}
	if m.CpuNice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuNice))))
		i--
		dAtA[i] = 0x41
	}
	if m.CpuUser != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuUser))))
		i--
		dAtA[i] = 0x39
	}
	if m.CpuSintr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuSintr))))
		i--
		dAtA[i] = 0x31
	}
	if m.CpuHintr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuHintr))))
		i--
		dAtA[i] = 0x29
	}
	if m.CpuIowait != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuIowait))))
		i--
		dAtA[i] = 0x21
	}
	if m.CpuIdle != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuIdle))))
		i--
		dAtA[i] = 0x19
	}
	if m.CpuSystem != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuSystem))))
		i--
		dAtA[i] = 0x11
	}
	if m.CpuUtilization != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuUtilization))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *CpuFreqOnDemandInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CpuFreqOnDemandInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CpuFreqOnDemandInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Values != nil {
		{
			size, err := m.Values.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Tags != nil {
		{
			size, err := m.Tags.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CpuFreqOnDemandInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CpuFreqOnDemandInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CpuFreqOnDemandInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CpuSpeed != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuSpeed))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *MemoryOnDemandInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoryOnDemandInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoryOnDemandInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Values != nil {
		{
			size, err := m.Values.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Tags != nil {
		{
			size, err := m.Tags.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MemoryOnDemandInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoryOnDemandInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoryOnDemandInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MemCached != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemCached))))
		i--
		dAtA[i] = 0x39
	}
	if m.MemBuffers != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemBuffers))))
		i--
		dAtA[i] = 0x31
	}
	if m.MemShared != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemShared))))
		i--
		dAtA[i] = 0x29
	}
	if m.MemFree != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemFree))))
		i--
		dAtA[i] = 0x21
	}
	if m.MemUsed != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemUsed))))
		i--
		dAtA[i] = 0x19
	}
	if m.MemTotal != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemTotal))))
		i--
		dAtA[i] = 0x11
	}
	if m.MemUtilization != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemUtilization))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *DiskOnDemandInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiskOnDemandInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiskOnDemandInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Values != nil {
		{
			size, err := m.Values.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Tags != nil {
		{
			size, err := m.Tags.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DiskOnDemandInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiskOnDemandInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiskOnDemandInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OpsWrite != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.OpsWrite))))
		i--
		dAtA[i] = 0x41
	}
	if m.OpsRead != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.OpsRead))))
		i--
		dAtA[i] = 0x39
	}
	if m.KbWritten != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.KbWritten))))
		i--
		dAtA[i] = 0x31
	}
	if m.KbRead != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.KbRead))))
		i--
		dAtA[i] = 0x29
	}
	if m.DiskUtilization != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DiskUtilization))))
		i--
		dAtA[i] = 0x21
	}
	if m.DiskUsed != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DiskUsed))))
		i--
		dAtA[i] = 0x19
	}
	if m.DiskTotal != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DiskTotal))))
		i--
		dAtA[i] = 0x11
	}
	if m.DiskFree != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DiskFree))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *NetworkOnDemandInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkOnDemandInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkOnDemandInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Values != nil {
		{
			size, err := m.Values.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Tags != nil {
		{
			size, err := m.Tags.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkOnDemandInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkOnDemandInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkOnDemandInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PktsOut != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PktsOut))))
		i--
		dAtA[i] = 0x21
	}
	if m.PktsIn != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PktsIn))))
		i--
		dAtA[i] = 0x19
	}
	if m.BytesOut != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BytesOut))))
		i--
		dAtA[i] = 0x11
	}
	if m.BytesIn != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BytesIn))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *MCISMonInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MCISMonInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MCISMonInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SpecId) > 0 {
		i -= len(m.SpecId)
		copy(dAtA[i:], m.SpecId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.SpecId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Elapsed) > 0 {
		i -= len(m.Elapsed)
		copy(dAtA[i:], m.Elapsed)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Elapsed)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Desc) > 0 {
		i -= len(m.Desc)
		copy(dAtA[i:], m.Desc)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Desc)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Unit) > 0 {
		i -= len(m.Unit)
		copy(dAtA[i:], m.Unit)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Unit)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CpuInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CpuInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CpuInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Tags != nil {
		{
			size, err := m.Tags.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CpuInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CpuInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CpuInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x62
	}
	if m.CpuGuestNice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuGuestNice))))
		i--
		dAtA[i] = 0x59
	}
	if m.CpuGuest != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuGuest))))
		i--
		dAtA[i] = 0x51
	}
	if m.CpuSteal != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuSteal))))
		i--
		dAtA[i] = 0x49
	}
	if m.CpuNice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuNice))))
		i--
		dAtA[i] = 0x41
	}
	if m.CpuUser != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuUser))))
		i--
		dAtA[i] = 0x39
	}
	if m.CpuSintr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuSintr))))
		i--
		dAtA[i] = 0x31
	}
	if m.CpuHintr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuHintr))))
		i--
		dAtA[i] = 0x29
	}
	if m.CpuIowait != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuIowait))))
		i--
		dAtA[i] = 0x21
	}
	if m.CpuIdle != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuIdle))))
		i--
		dAtA[i] = 0x19
	}
	if m.CpuSystem != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuSystem))))
		i--
		dAtA[i] = 0x11
	}
	if m.CpuUtilization != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuUtilization))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *CpuFreqInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CpuFreqInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CpuFreqInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Tags != nil {
		{
			size, err := m.Tags.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CpuFreqInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CpuFreqInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CpuFreqInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x12
	}
	if m.CpuSpeed != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuSpeed))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *MemoryInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoryInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoryInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Tags != nil {
		{
			size, err := m.Tags.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MemoryInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoryInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoryInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x42
	}
	if m.MemCached != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemCached))))
		i--
		dAtA[i] = 0x39
	}
	if m.MemBuffers != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemBuffers))))
		i--
		dAtA[i] = 0x31
	}
	if m.MemShared != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemShared))))
		i--
		dAtA[i] = 0x29
	}
	if m.MemFree != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemFree))))
		i--
		dAtA[i] = 0x21
	}
	if m.MemUsed != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemUsed))))
		i--
		dAtA[i] = 0x19
	}
	if m.MemTotal != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemTotal))))
		i--
		dAtA[i] = 0x11
	}
	if m.MemUtilization != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemUtilization))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *DiskInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiskInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiskInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Tags != nil {
		{
			size, err := m.Tags.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DiskInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiskInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiskInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Writes != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Writes))))
		i--
		dAtA[i] = 0x51
	}
	if m.WriteTime != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.WriteTime))))
		i--
		dAtA[i] = 0x49
	}
	if m.WriteBytes != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.WriteBytes))))
		i--
		dAtA[i] = 0x41
	}
	if m.UsedPercent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.UsedPercent))))
		i--
		dAtA[i] = 0x39
	}
	if m.Used != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Used))))
		i--
		dAtA[i] = 0x31
	}
	if m.Total != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Total))))
		i--
		dAtA[i] = 0x29
	}
	if m.Reads != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Reads))))
		i--
		dAtA[i] = 0x21
	}
	if m.ReadTime != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ReadTime))))
		i--
		dAtA[i] = 0x19
	}
	if m.ReadBytes != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ReadBytes))))
		i--
		dAtA[i] = 0x11
	}
	if m.Free != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Free))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *NetworkInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Tags != nil {
		{
			size, err := m.Tags.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x2a
	}
	if m.PktsOut != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PktsOut))))
		i--
		dAtA[i] = 0x21
	}
	if m.PktsIn != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PktsIn))))
		i--
		dAtA[i] = 0x19
	}
	if m.BytesOut != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BytesOut))))
		i--
		dAtA[i] = 0x11
	}
	if m.BytesIn != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BytesIn))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *MonitoringConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MonitoringConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MonitoringConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MonitoringConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MonitoringConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MonitoringConfigResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MonitoringConfigInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MonitoringConfigInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MonitoringConfigInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MonitoringPolicy) > 0 {
		i -= len(m.MonitoringPolicy)
		copy(dAtA[i:], m.MonitoringPolicy)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.MonitoringPolicy)))
		i--
		dAtA[i] = 0x2a
	}
	if m.MaxHostCount != 0 {
		i = encodeVarintCbdragonfly(dAtA, i, uint64(m.MaxHostCount))
		i--
		dAtA[i] = 0x20
	}
	if m.CollectorInterval != 0 {
		i = encodeVarintCbdragonfly(dAtA, i, uint64(m.CollectorInterval))
		i--
		dAtA[i] = 0x10
	}
	if m.AgentInterval != 0 {
		i = encodeVarintCbdragonfly(dAtA, i, uint64(m.AgentInterval))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InstallAgentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstallAgentRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstallAgentRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Port) > 0 {
		i -= len(m.Port)
		copy(dAtA[i:], m.Port)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Port)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.CspType) > 0 {
		i -= len(m.CspType)
		copy(dAtA[i:], m.CspType)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.CspType)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SshKey) > 0 {
		i -= len(m.SshKey)
		copy(dAtA[i:], m.SshKey)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.SshKey)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PublicIp) > 0 {
		i -= len(m.PublicIp)
		copy(dAtA[i:], m.PublicIp)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.PublicIp)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.VmId) > 0 {
		i -= len(m.VmId)
		copy(dAtA[i:], m.VmId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.VmId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.McisId) > 0 {
		i -= len(m.McisId)
		copy(dAtA[i:], m.McisId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.McisId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NsId) > 0 {
		i -= len(m.NsId)
		copy(dAtA[i:], m.NsId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.NsId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCbdragonfly(dAtA []byte, offset int, v uint64) int {
	offset -= sovCbdragonfly(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tags) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NsId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.McisId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.VmId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VMMonQryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NsId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.McisId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.VmId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.PeriodType)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.StatisticsCriteria)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.Duration)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VMOnDemandMonQryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NsId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.McisId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.VmId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.AgentIp)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VMMCISMonQryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NsId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.McisId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.VmId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.AgentIp)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.MetricName)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CpuOnDemandInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Tags != nil {
		l = m.Tags.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Values != nil {
		l = m.Values.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CpuOnDemandInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CpuUtilization != 0 {
		n += 9
	}
	if m.CpuSystem != 0 {
		n += 9
	}
	if m.CpuIdle != 0 {
		n += 9
	}
	if m.CpuIowait != 0 {
		n += 9
	}
	if m.CpuHintr != 0 {
		n += 9
	}
	if m.CpuSintr != 0 {
		n += 9
	}
	if m.CpuUser != 0 {
		n += 9
	}
	if m.CpuNice != 0 {
		n += 9
	}
	if m.CpuSteal != 0 {
		n += 9
	}
	if m.CpuGuest != 0 {
		n += 9
	}
	if m.CpuGuestNice != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CpuFreqOnDemandInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Tags != nil {
		l = m.Tags.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Values != nil {
		l = m.Values.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CpuFreqOnDemandInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CpuSpeed != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MemoryOnDemandInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Tags != nil {
		l = m.Tags.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Values != nil {
		l = m.Values.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MemoryOnDemandInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemUtilization != 0 {
		n += 9
	}
	if m.MemTotal != 0 {
		n += 9
	}
	if m.MemUsed != 0 {
		n += 9
	}
	if m.MemFree != 0 {
		n += 9
	}
	if m.MemShared != 0 {
		n += 9
	}
	if m.MemBuffers != 0 {
		n += 9
	}
	if m.MemCached != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiskOnDemandInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Tags != nil {
		l = m.Tags.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Values != nil {
		l = m.Values.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiskOnDemandInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiskFree != 0 {
		n += 9
	}
	if m.DiskTotal != 0 {
		n += 9
	}
	if m.DiskUsed != 0 {
		n += 9
	}
	if m.DiskUtilization != 0 {
		n += 9
	}
	if m.KbRead != 0 {
		n += 9
	}
	if m.KbWritten != 0 {
		n += 9
	}
	if m.OpsRead != 0 {
		n += 9
	}
	if m.OpsWrite != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkOnDemandInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Tags != nil {
		l = m.Tags.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Values != nil {
		l = m.Values.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkOnDemandInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BytesIn != 0 {
		n += 9
	}
	if m.BytesOut != 0 {
		n += 9
	}
	if m.PktsIn != 0 {
		n += 9
	}
	if m.PktsOut != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MCISMonInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.Unit)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.Elapsed)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.SpecId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CpuInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Tags != nil {
		l = m.Tags.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovCbdragonfly(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CpuInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CpuUtilization != 0 {
		n += 9
	}
	if m.CpuSystem != 0 {
		n += 9
	}
	if m.CpuIdle != 0 {
		n += 9
	}
	if m.CpuIowait != 0 {
		n += 9
	}
	if m.CpuHintr != 0 {
		n += 9
	}
	if m.CpuSintr != 0 {
		n += 9
	}
	if m.CpuUser != 0 {
		n += 9
	}
	if m.CpuNice != 0 {
		n += 9
	}
	if m.CpuSteal != 0 {
		n += 9
	}
	if m.CpuGuest != 0 {
		n += 9
	}
	if m.CpuGuestNice != 0 {
		n += 9
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CpuFreqInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Tags != nil {
		l = m.Tags.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovCbdragonfly(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CpuFreqInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CpuSpeed != 0 {
		n += 9
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MemoryInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Tags != nil {
		l = m.Tags.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovCbdragonfly(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MemoryInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemUtilization != 0 {
		n += 9
	}
	if m.MemTotal != 0 {
		n += 9
	}
	if m.MemUsed != 0 {
		n += 9
	}
	if m.MemFree != 0 {
		n += 9
	}
	if m.MemShared != 0 {
		n += 9
	}
	if m.MemBuffers != 0 {
		n += 9
	}
	if m.MemCached != 0 {
		n += 9
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiskInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Tags != nil {
		l = m.Tags.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovCbdragonfly(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiskInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Free != 0 {
		n += 9
	}
	if m.ReadBytes != 0 {
		n += 9
	}
	if m.ReadTime != 0 {
		n += 9
	}
	if m.Reads != 0 {
		n += 9
	}
	if m.Total != 0 {
		n += 9
	}
	if m.Used != 0 {
		n += 9
	}
	if m.UsedPercent != 0 {
		n += 9
	}
	if m.WriteBytes != 0 {
		n += 9
	}
	if m.WriteTime != 0 {
		n += 9
	}
	if m.Writes != 0 {
		n += 9
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Tags != nil {
		l = m.Tags.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovCbdragonfly(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BytesIn != 0 {
		n += 9
	}
	if m.BytesOut != 0 {
		n += 9
	}
	if m.PktsIn != 0 {
		n += 9
	}
	if m.PktsOut != 0 {
		n += 9
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MonitoringConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MonitoringConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MonitoringConfigInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AgentInterval != 0 {
		n += 1 + sovCbdragonfly(uint64(m.AgentInterval))
	}
	if m.CollectorInterval != 0 {
		n += 1 + sovCbdragonfly(uint64(m.CollectorInterval))
	}
	if m.MaxHostCount != 0 {
		n += 1 + sovCbdragonfly(uint64(m.MaxHostCount))
	}
	l = len(m.MonitoringPolicy)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InstallAgentRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NsId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.McisId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.VmId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.PublicIp)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.SshKey)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.CspType)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.Port)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCbdragonfly(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCbdragonfly(x uint64) (n int) {
	return sovCbdragonfly(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tags) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tags: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tags: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NsId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NsId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field McisId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.McisId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMMonQryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMMonQryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMMonQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NsId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NsId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field McisId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.McisId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeriodType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatisticsCriteria", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatisticsCriteria = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Duration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMOnDemandMonQryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMOnDemandMonQryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMOnDemandMonQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NsId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NsId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field McisId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.McisId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AgentIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMMCISMonQryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMMCISMonQryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMMCISMonQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NsId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NsId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field McisId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.McisId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AgentIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CpuOnDemandInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CpuOnDemandInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CpuOnDemandInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = &Tags{}
			}
			if err := m.Tags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Values == nil {
				m.Values = &CpuOnDemandInfo{}
			}
			if err := m.Values.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CpuOnDemandInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CpuOnDemandInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CpuOnDemandInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUtilization", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuUtilization = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSystem", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuSystem = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuIdle", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuIdle = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuIowait", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuIowait = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuHintr", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuHintr = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSintr", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuSintr = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUser", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuUser = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuNice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuNice = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSteal", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuSteal = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuGuest", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuGuest = float64(math.Float64frombits(v))
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuGuestNice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuGuestNice = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CpuFreqOnDemandInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CpuFreqOnDemandInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CpuFreqOnDemandInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = &Tags{}
			}
			if err := m.Tags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Values == nil {
				m.Values = &CpuFreqOnDemandInfo{}
			}
			if err := m.Values.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CpuFreqOnDemandInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CpuFreqOnDemandInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CpuFreqOnDemandInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSpeed", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuSpeed = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryOnDemandInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoryOnDemandInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoryOnDemandInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = &Tags{}
			}
			if err := m.Tags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Values == nil {
				m.Values = &MemoryOnDemandInfo{}
			}
			if err := m.Values.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryOnDemandInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoryOnDemandInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoryOnDemandInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemUtilization", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemUtilization = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemTotal", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemTotal = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemUsed", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemUsed = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemFree", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemFree = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemShared", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemShared = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemBuffers", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemBuffers = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemCached", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemCached = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiskOnDemandInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiskOnDemandInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiskOnDemandInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = &Tags{}
			}
			if err := m.Tags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Values == nil {
				m.Values = &DiskOnDemandInfo{}
			}
			if err := m.Values.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiskOnDemandInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiskOnDemandInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiskOnDemandInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskFree", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DiskFree = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskTotal", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DiskTotal = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskUsed", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DiskUsed = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskUtilization", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DiskUtilization = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field KbRead", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.KbRead = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field KbWritten", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.KbWritten = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpsRead", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.OpsRead = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpsWrite", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.OpsWrite = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkOnDemandInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkOnDemandInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkOnDemandInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = &Tags{}
			}
			if err := m.Tags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Values == nil {
				m.Values = &NetworkOnDemandInfo{}
			}
			if err := m.Values.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkOnDemandInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkOnDemandInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkOnDemandInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesIn", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BytesIn = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesOut", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BytesOut = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PktsIn", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PktsIn = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PktsOut", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PktsOut = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MCISMonInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MCISMonInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MCISMonInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elapsed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Elapsed = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpecId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CpuInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CpuInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CpuInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = &Tags{}
			}
			if err := m.Tags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &CpuInfo{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CpuInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CpuInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CpuInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUtilization", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuUtilization = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSystem", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuSystem = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuIdle", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuIdle = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuIowait", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuIowait = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuHintr", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuHintr = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSintr", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuSintr = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUser", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuUser = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuNice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuNice = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSteal", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuSteal = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuGuest", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuGuest = float64(math.Float64frombits(v))
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuGuestNice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuGuestNice = float64(math.Float64frombits(v))
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CpuFreqInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CpuFreqInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CpuFreqInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = &Tags{}
			}
			if err := m.Tags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &CpuFreqInfo{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CpuFreqInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CpuFreqInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CpuFreqInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSpeed", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuSpeed = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoryInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoryInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = &Tags{}
			}
			if err := m.Tags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &MemoryInfo{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoryInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemUtilization", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemUtilization = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemTotal", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemTotal = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemUsed", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemUsed = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemFree", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemFree = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemShared", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemShared = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemBuffers", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemBuffers = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemCached", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemCached = float64(math.Float64frombits(v))
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiskInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiskInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiskInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = &Tags{}
			}
			if err := m.Tags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &DiskInfo{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiskInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiskInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiskInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Free", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Free = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadBytes", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ReadBytes = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ReadTime = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reads", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Reads = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Total = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Used", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Used = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedPercent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.UsedPercent = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteBytes", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.WriteBytes = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.WriteTime = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Writes", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Writes = float64(math.Float64frombits(v))
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = &Tags{}
			}
			if err := m.Tags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &NetworkInfo{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesIn", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BytesIn = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesOut", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BytesOut = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PktsIn", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PktsIn = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PktsOut", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PktsOut = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MonitoringConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MonitoringConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MonitoringConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Item == nil {
				m.Item = &MonitoringConfigInfo{}
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MonitoringConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MonitoringConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MonitoringConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Item == nil {
				m.Item = &MonitoringConfigInfo{}
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MonitoringConfigInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MonitoringConfigInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MonitoringConfigInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentInterval", wireType)
			}
			m.AgentInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AgentInterval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectorInterval", wireType)
			}
			m.CollectorInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectorInterval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxHostCount", wireType)
			}
			m.MaxHostCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxHostCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonitoringPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MonitoringPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstallAgentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstallAgentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstallAgentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NsId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NsId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field McisId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.McisId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SshKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SshKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CspType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CspType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Port = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCbdragonfly(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCbdragonfly
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCbdragonfly
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCbdragonfly
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCbdragonfly        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCbdragonfly          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCbdragonfly = fmt.Errorf("proto: unexpected end of group")
)
